<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OFFIS DCMTK: OFString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OFFIS DCMTK
   &#160;<span id="projectnumber">Version 3.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classOFString-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OFString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>a simple string class that implements a subset of std::string.  
 <a href="classOFString.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac689b404c6b29147336541eb23f1d6b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac689b404c6b29147336541eb23f1d6b5"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ac689b404c6b29147336541eb23f1d6b5">size_type</a></td></tr>
<tr class="memdesc:ac689b404c6b29147336541eb23f1d6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">type that is used for lengths and offsets <br/></td></tr>
<tr class="separator:ac689b404c6b29147336541eb23f1d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b62abdd00d1268bc14b18492da8d665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b62abdd00d1268bc14b18492da8d665"></a>
typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a1b62abdd00d1268bc14b18492da8d665">value_type</a></td></tr>
<tr class="memdesc:a1b62abdd00d1268bc14b18492da8d665"><td class="mdescLeft">&#160;</td><td class="mdescRight">type that is contained in this <br/></td></tr>
<tr class="separator:a1b62abdd00d1268bc14b18492da8d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6e1b66f6870d74b0cd281fa2cb6157"><td class="memItemLeft" align="right" valign="top">typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a1b6e1b66f6870d74b0cd281fa2cb6157">iterator</a></td></tr>
<tr class="memdesc:a1b6e1b66f6870d74b0cd281fa2cb6157"><td class="mdescLeft">&#160;</td><td class="mdescRight">this typedef can be used to iterate over an string.  <a href="#a1b6e1b66f6870d74b0cd281fa2cb6157">More...</a><br/></td></tr>
<tr class="separator:a1b6e1b66f6870d74b0cd281fa2cb6157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170182e25a85b8fc2da59ab421491399"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a170182e25a85b8fc2da59ab421491399"></a>
typedef <a class="el" href="classOFString.html#a1b6e1b66f6870d74b0cd281fa2cb6157">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a170182e25a85b8fc2da59ab421491399">const_iterator</a></td></tr>
<tr class="memdesc:a170182e25a85b8fc2da59ab421491399"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is just an alias for iterator since iterator is already "const" <br/></td></tr>
<tr class="separator:a170182e25a85b8fc2da59ab421491399"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f9197dbfa6e51669cfdeae9f6002667"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a2f9197dbfa6e51669cfdeae9f6002667">OFString</a> ()</td></tr>
<tr class="memdesc:a2f9197dbfa6e51669cfdeae9f6002667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a2f9197dbfa6e51669cfdeae9f6002667">More...</a><br/></td></tr>
<tr class="separator:a2f9197dbfa6e51669cfdeae9f6002667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa14142b6a4e2d5de21029600bf19885"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aaa14142b6a4e2d5de21029600bf19885">OFString</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos=0, size_t n=OFString_npos)</td></tr>
<tr class="memdesc:aaa14142b6a4e2d5de21029600bf19885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a string from the given input string str.  <a href="#aaa14142b6a4e2d5de21029600bf19885">More...</a><br/></td></tr>
<tr class="separator:aaa14142b6a4e2d5de21029600bf19885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf7c011bb848908dbdc456af47c5c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ab9bf7c011bb848908dbdc456af47c5c7">OFString</a> (const char *s, size_t n)</td></tr>
<tr class="memdesc:ab9bf7c011bb848908dbdc456af47c5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor copies n characters starting at s, and constructs a string object initialized with the corresponding characters.  <a href="#ab9bf7c011bb848908dbdc456af47c5c7">More...</a><br/></td></tr>
<tr class="separator:ab9bf7c011bb848908dbdc456af47c5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f57d27ca9355904c5d43709e3da7354"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a2f57d27ca9355904c5d43709e3da7354">OFString</a> (const char *s)</td></tr>
<tr class="memdesc:a2f57d27ca9355904c5d43709e3da7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a string object from the array pointed to by the input pointer s.  <a href="#a2f57d27ca9355904c5d43709e3da7354">More...</a><br/></td></tr>
<tr class="separator:a2f57d27ca9355904c5d43709e3da7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f3b0b39a7a65d366114dff77acb46d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ad2f3b0b39a7a65d366114dff77acb46d">OFString</a> (size_t rep, char c)</td></tr>
<tr class="memdesc:ad2f3b0b39a7a65d366114dff77acb46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a string object with the character c repeated rep times.  <a href="#ad2f3b0b39a7a65d366114dff77acb46d">More...</a><br/></td></tr>
<tr class="separator:ad2f3b0b39a7a65d366114dff77acb46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b10b2a4e1e653ed02922eff9d4dbf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90b10b2a4e1e653ed02922eff9d4dbf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a90b10b2a4e1e653ed02922eff9d4dbf9">~OFString</a> ()</td></tr>
<tr class="memdesc:a90b10b2a4e1e653ed02922eff9d4dbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br/></td></tr>
<tr class="separator:a90b10b2a4e1e653ed02922eff9d4dbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da022549921156b66a7c7c79ae3dae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5da022549921156b66a7c7c79ae3dae0">operator=</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;rhs)</td></tr>
<tr class="memdesc:a5da022549921156b66a7c7c79ae3dae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assigns the input string to the current string.  <a href="#a5da022549921156b66a7c7c79ae3dae0">More...</a><br/></td></tr>
<tr class="separator:a5da022549921156b66a7c7c79ae3dae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5503a30883b45f4463cb457b0e7dd866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5503a30883b45f4463cb457b0e7dd866">operator=</a> (const char *s)</td></tr>
<tr class="memdesc:a5503a30883b45f4463cb457b0e7dd866"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input s and assigns it to the current string.  <a href="#a5503a30883b45f4463cb457b0e7dd866">More...</a><br/></td></tr>
<tr class="separator:a5503a30883b45f4463cb457b0e7dd866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b3a312bfe55d33edc807da60bf5882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a03b3a312bfe55d33edc807da60bf5882">operator=</a> (char s)</td></tr>
<tr class="memdesc:a03b3a312bfe55d33edc807da60bf5882"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input s and assigns it to the current string.  <a href="#a03b3a312bfe55d33edc807da60bf5882">More...</a><br/></td></tr>
<tr class="separator:a03b3a312bfe55d33edc807da60bf5882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a13c8574752c26838e61ddc8469b329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5a13c8574752c26838e61ddc8469b329">operator+=</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;rhs)</td></tr>
<tr class="memdesc:a5a13c8574752c26838e61ddc8469b329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the input string to the current string.  <a href="#a5a13c8574752c26838e61ddc8469b329">More...</a><br/></td></tr>
<tr class="separator:a5a13c8574752c26838e61ddc8469b329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd888544a2c4d9febfe9d769cf839f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5bd888544a2c4d9febfe9d769cf839f0">operator+=</a> (const char *s)</td></tr>
<tr class="memdesc:a5bd888544a2c4d9febfe9d769cf839f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input s and appends it to the current string.  <a href="#a5bd888544a2c4d9febfe9d769cf839f0">More...</a><br/></td></tr>
<tr class="separator:a5bd888544a2c4d9febfe9d769cf839f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66af336e6670ff83364c6c8424150b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aae66af336e6670ff83364c6c8424150b">operator+=</a> (char s)</td></tr>
<tr class="memdesc:aae66af336e6670ff83364c6c8424150b"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input s and appends it to the current string.  <a href="#aae66af336e6670ff83364c6c8424150b">More...</a><br/></td></tr>
<tr class="separator:aae66af336e6670ff83364c6c8424150b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67028a957b5ff4b31511981c76d559f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ac67028a957b5ff4b31511981c76d559f">append</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos=0, size_t n=OFString_npos)</td></tr>
<tr class="memdesc:ac67028a957b5ff4b31511981c76d559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends characters from the input string str to the current string object.  <a href="#ac67028a957b5ff4b31511981c76d559f">More...</a><br/></td></tr>
<tr class="separator:ac67028a957b5ff4b31511981c76d559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6e455389dc7d40ec7a358c8be4ba76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a1a6e455389dc7d40ec7a358c8be4ba76">append</a> (const char *s, size_t n)</td></tr>
<tr class="memdesc:a1a6e455389dc7d40ec7a358c8be4ba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and appends it to the current string.  <a href="#a1a6e455389dc7d40ec7a358c8be4ba76">More...</a><br/></td></tr>
<tr class="separator:a1a6e455389dc7d40ec7a358c8be4ba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1854bb074f5ac64e4130bb8f5f2dbf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ab1854bb074f5ac64e4130bb8f5f2dbf2">append</a> (const char *s)</td></tr>
<tr class="memdesc:ab1854bb074f5ac64e4130bb8f5f2dbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and appends it to the current string.  <a href="#ab1854bb074f5ac64e4130bb8f5f2dbf2">More...</a><br/></td></tr>
<tr class="separator:ab1854bb074f5ac64e4130bb8f5f2dbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649aa6dd2eaca33881abb0e9075d5b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a649aa6dd2eaca33881abb0e9075d5b9d">append</a> (size_t rep, char c)</td></tr>
<tr class="memdesc:a649aa6dd2eaca33881abb0e9075d5b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and appends it to the current string.  <a href="#a649aa6dd2eaca33881abb0e9075d5b9d">More...</a><br/></td></tr>
<tr class="separator:a649aa6dd2eaca33881abb0e9075d5b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5e1ff5ab7833cee1cca6b3b42cda3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a3d5e1ff5ab7833cee1cca6b3b42cda3e">assign</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos, size_t n)</td></tr>
<tr class="memdesc:a3d5e1ff5ab7833cee1cca6b3b42cda3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns characters from the input string str to the current string object.  <a href="#a3d5e1ff5ab7833cee1cca6b3b42cda3e">More...</a><br/></td></tr>
<tr class="separator:a3d5e1ff5ab7833cee1cca6b3b42cda3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b454d16e5db4985a4b678c0bc45560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a34b454d16e5db4985a4b678c0bc45560">assign</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str)</td></tr>
<tr class="memdesc:a34b454d16e5db4985a4b678c0bc45560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns input string str to the current string object.  <a href="#a34b454d16e5db4985a4b678c0bc45560">More...</a><br/></td></tr>
<tr class="separator:a34b454d16e5db4985a4b678c0bc45560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c19d55c5a7002c62d66b8d80b559b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5c19d55c5a7002c62d66b8d80b559b93">assign</a> (const char *s, size_t n)</td></tr>
<tr class="memdesc:a5c19d55c5a7002c62d66b8d80b559b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and assigns it to the current string.  <a href="#a5c19d55c5a7002c62d66b8d80b559b93">More...</a><br/></td></tr>
<tr class="separator:a5c19d55c5a7002c62d66b8d80b559b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d8707b22e143255db1e341ed749ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aa5d8707b22e143255db1e341ed749ca0">assign</a> (const char *s)</td></tr>
<tr class="memdesc:aa5d8707b22e143255db1e341ed749ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and assigns it to the current string.  <a href="#aa5d8707b22e143255db1e341ed749ca0">More...</a><br/></td></tr>
<tr class="separator:aa5d8707b22e143255db1e341ed749ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa7553c7040cde61b15883331c64ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a8fa7553c7040cde61b15883331c64ad3">assign</a> (size_t rep, char c)</td></tr>
<tr class="memdesc:a8fa7553c7040cde61b15883331c64ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and assigns it to the current string.  <a href="#a8fa7553c7040cde61b15883331c64ad3">More...</a><br/></td></tr>
<tr class="separator:a8fa7553c7040cde61b15883331c64ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89263f9aff57699a38e359b080bd8d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a89263f9aff57699a38e359b080bd8d95">insert</a> (size_t pos1, const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos2=0, size_t n=OFString_npos)</td></tr>
<tr class="memdesc:a89263f9aff57699a38e359b080bd8d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts at most n characters, starting at position pos2 of the input string str, into the current string.  <a href="#a89263f9aff57699a38e359b080bd8d95">More...</a><br/></td></tr>
<tr class="separator:a89263f9aff57699a38e359b080bd8d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701cd6c7bf08768affcbadc23ee96290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a701cd6c7bf08768affcbadc23ee96290">insert</a> (size_t pos, const char *s, size_t n)</td></tr>
<tr class="memdesc:a701cd6c7bf08768affcbadc23ee96290"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and inserts it into the current string.  <a href="#a701cd6c7bf08768affcbadc23ee96290">More...</a><br/></td></tr>
<tr class="separator:a701cd6c7bf08768affcbadc23ee96290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8a365f2f07a962b6199e60d5de6f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aaf8a365f2f07a962b6199e60d5de6f01">insert</a> (size_t pos, const char *s)</td></tr>
<tr class="memdesc:aaf8a365f2f07a962b6199e60d5de6f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and inserts it into the current string.  <a href="#aaf8a365f2f07a962b6199e60d5de6f01">More...</a><br/></td></tr>
<tr class="separator:aaf8a365f2f07a962b6199e60d5de6f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39855574592774a02c8f0bfba2fae77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ac39855574592774a02c8f0bfba2fae77">insert</a> (size_t pos, size_t rep, char c)</td></tr>
<tr class="memdesc:ac39855574592774a02c8f0bfba2fae77"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and inserts it into the current string.  <a href="#ac39855574592774a02c8f0bfba2fae77">More...</a><br/></td></tr>
<tr class="separator:ac39855574592774a02c8f0bfba2fae77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8e79ca185d93f6a089c57ac58748fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a9f8e79ca185d93f6a089c57ac58748fa">erase</a> (size_t pos=0, size_t n=OFString_npos)</td></tr>
<tr class="memdesc:a9f8e79ca185d93f6a089c57ac58748fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes up to n characters from the string starting from position pos.  <a href="#a9f8e79ca185d93f6a089c57ac58748fa">More...</a><br/></td></tr>
<tr class="separator:a9f8e79ca185d93f6a089c57ac58748fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb618591e2ad33202d5b505ffd06445f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#adb618591e2ad33202d5b505ffd06445f">replace</a> (size_t pos1, size_t n1, const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos2=0, size_t n2=OFString_npos)</td></tr>
<tr class="memdesc:adb618591e2ad33202d5b505ffd06445f"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces a range of characters in the current string with a range of characters taken from the input string str.  <a href="#adb618591e2ad33202d5b505ffd06445f">More...</a><br/></td></tr>
<tr class="separator:adb618591e2ad33202d5b505ffd06445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868371ad7a8273594f6ff651e4548889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a868371ad7a8273594f6ff651e4548889">replace</a> (size_t pos, size_t n, const char *s, size_t n2)</td></tr>
<tr class="memdesc:a868371ad7a8273594f6ff651e4548889"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and replaces the range [pos, n] in the current string with the constructed string.  <a href="#a868371ad7a8273594f6ff651e4548889">More...</a><br/></td></tr>
<tr class="separator:a868371ad7a8273594f6ff651e4548889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c92b4ff869e09c9cfc0492e80fb523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a89c92b4ff869e09c9cfc0492e80fb523">replace</a> (size_t pos, size_t n, const char *s)</td></tr>
<tr class="memdesc:a89c92b4ff869e09c9cfc0492e80fb523"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and replaces the range [pos, n] in the current string with the constructed string.  <a href="#a89c92b4ff869e09c9cfc0492e80fb523">More...</a><br/></td></tr>
<tr class="separator:a89c92b4ff869e09c9cfc0492e80fb523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc425dc9e2bd4484489fcd304837f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a3fc425dc9e2bd4484489fcd304837f09">replace</a> (size_t pos, size_t n, size_t rep, char s)</td></tr>
<tr class="memdesc:a3fc425dc9e2bd4484489fcd304837f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and replaces the range [pos, n] in the current string with the constructed string.  <a href="#a3fc425dc9e2bd4484489fcd304837f09">More...</a><br/></td></tr>
<tr class="separator:a3fc425dc9e2bd4484489fcd304837f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce83e87b2c25c10375bb86271f51826"><td class="memItemLeft" align="right" valign="top">const char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5ce83e87b2c25c10375bb86271f51826">at</a> (size_t pos) const </td></tr>
<tr class="memdesc:a5ce83e87b2c25c10375bb86271f51826"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a constant reference to the character at position pos of the current string.  <a href="#a5ce83e87b2c25c10375bb86271f51826">More...</a><br/></td></tr>
<tr class="separator:a5ce83e87b2c25c10375bb86271f51826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b86f83b7fb166275ebfdbbe983fb9c"><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a80b86f83b7fb166275ebfdbbe983fb9c">at</a> (size_t pos)</td></tr>
<tr class="memdesc:a80b86f83b7fb166275ebfdbbe983fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a non-const reference to the character at position pos of the current string.  <a href="#a80b86f83b7fb166275ebfdbbe983fb9c">More...</a><br/></td></tr>
<tr class="separator:a80b86f83b7fb166275ebfdbbe983fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2614b9d7a5d0ba6a349de35a1d541c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a4a2614b9d7a5d0ba6a349de35a1d541c">operator[]</a> (size_t pos) const </td></tr>
<tr class="memdesc:a4a2614b9d7a5d0ba6a349de35a1d541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element at position pos of the current string.  <a href="#a4a2614b9d7a5d0ba6a349de35a1d541c">More...</a><br/></td></tr>
<tr class="separator:a4a2614b9d7a5d0ba6a349de35a1d541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae05a9c93953f63531c20d0f0c5c1b3b"><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aae05a9c93953f63531c20d0f0c5c1b3b">operator[]</a> (size_t pos)</td></tr>
<tr class="memdesc:aae05a9c93953f63531c20d0f0c5c1b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the element at position pos of the current string.  <a href="#aae05a9c93953f63531c20d0f0c5c1b3b">More...</a><br/></td></tr>
<tr class="separator:aae05a9c93953f63531c20d0f0c5c1b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f2afbb21f305a5b1b4ec62ec9dc4bc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a82f2afbb21f305a5b1b4ec62ec9dc4bc">c_str</a> () const </td></tr>
<tr class="memdesc:a82f2afbb21f305a5b1b4ec62ec9dc4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the initial element of an array of length <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>+1 whose first <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> elements equal the corresponding elements of the current string and whose last element is a null character.  <a href="#a82f2afbb21f305a5b1b4ec62ec9dc4bc">More...</a><br/></td></tr>
<tr class="separator:a82f2afbb21f305a5b1b4ec62ec9dc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47921917148fe9a39379e52ccbfda83d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a47921917148fe9a39379e52ccbfda83d">data</a> () const </td></tr>
<tr class="memdesc:a47921917148fe9a39379e52ccbfda83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> is nonzero, this function returns a pointer to the initial element of an array whose first <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> elements equal the corresponding elements of the string controlled by *this.  <a href="#a47921917148fe9a39379e52ccbfda83d">More...</a><br/></td></tr>
<tr class="separator:a47921917148fe9a39379e52ccbfda83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3a81790b4a9a4787ddf7c93ad5051e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e">size</a> () const </td></tr>
<tr class="memdesc:aaa3a81790b4a9a4787ddf7c93ad5051e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a count of the number of char-like objects currently in the string.  <a href="#aaa3a81790b4a9a4787ddf7c93ad5051e">More...</a><br/></td></tr>
<tr class="separator:aaa3a81790b4a9a4787ddf7c93ad5051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac614bab6a5df1a1af381071bdf3128f7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ac614bab6a5df1a1af381071bdf3128f7">length</a> () const </td></tr>
<tr class="memdesc:ac614bab6a5df1a1af381071bdf3128f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a count of the number of char-like objects currently in the string.  <a href="#ac614bab6a5df1a1af381071bdf3128f7">More...</a><br/></td></tr>
<tr class="separator:ac614bab6a5df1a1af381071bdf3128f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb19c72ef402a019368731cc5615b9d"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5bb19c72ef402a019368731cc5615b9d">empty</a> () const </td></tr>
<tr class="memdesc:a5bb19c72ef402a019368731cc5615b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the string is empty, false otherwise.  <a href="#a5bb19c72ef402a019368731cc5615b9d">More...</a><br/></td></tr>
<tr class="separator:a5bb19c72ef402a019368731cc5615b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62da8f78dee4485804cba6b0b75c613"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ae62da8f78dee4485804cba6b0b75c613">resize</a> (size_t n, char c= '\0')</td></tr>
<tr class="memdesc:ae62da8f78dee4485804cba6b0b75c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">if n &lt;= <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>, truncates the string to length n else it pads the extra locations with c.  <a href="#ae62da8f78dee4485804cba6b0b75c613">More...</a><br/></td></tr>
<tr class="separator:ae62da8f78dee4485804cba6b0b75c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ce8c967a6e6e3f5afc062104482202"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a79ce8c967a6e6e3f5afc062104482202">capacity</a> () const </td></tr>
<tr class="memdesc:a79ce8c967a6e6e3f5afc062104482202"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of the allocated storage in the string.  <a href="#a79ce8c967a6e6e3f5afc062104482202">More...</a><br/></td></tr>
<tr class="separator:a79ce8c967a6e6e3f5afc062104482202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7673cf5e31c1542a2a140540c1dc664b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a7673cf5e31c1542a2a140540c1dc664b">max_size</a> () const </td></tr>
<tr class="memdesc:a7673cf5e31c1542a2a140540c1dc664b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum size of a string which could possibly by allocated.  <a href="#a7673cf5e31c1542a2a140540c1dc664b">More...</a><br/></td></tr>
<tr class="separator:a7673cf5e31c1542a2a140540c1dc664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8804590373bfff07f395b9033c7c886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8804590373bfff07f395b9033c7c886"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ac8804590373bfff07f395b9033c7c886">clear</a> ()</td></tr>
<tr class="memdesc:ac8804590373bfff07f395b9033c7c886"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty the string of all contents <br/></td></tr>
<tr class="separator:ac8804590373bfff07f395b9033c7c886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5b3854ae3bfdd323ebfda499ed5001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aeb5b3854ae3bfdd323ebfda499ed5001">reserve</a> (size_t res_arg)</td></tr>
<tr class="memdesc:aeb5b3854ae3bfdd323ebfda499ed5001"><td class="mdescLeft">&#160;</td><td class="mdescRight">directive that informs a string of a planned change in size, so that it can manage the storage allocation accordingly.  <a href="#aeb5b3854ae3bfdd323ebfda499ed5001">More...</a><br/></td></tr>
<tr class="separator:aeb5b3854ae3bfdd323ebfda499ed5001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3599179906f759d794685b529e76e8b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aa3599179906f759d794685b529e76e8b">copy</a> (char *s, size_t n, size_t pos=0) const </td></tr>
<tr class="memdesc:aa3599179906f759d794685b529e76e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces the string designated by s with a copy of a range of characters from the current string.  <a href="#aa3599179906f759d794685b529e76e8b">More...</a><br/></td></tr>
<tr class="separator:aa3599179906f759d794685b529e76e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c72f6b7162c3c2155268fe47b8b6fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html">OFString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a3c72f6b7162c3c2155268fe47b8b6fda">substr</a> (size_t pos=0, size_t n=OFString_npos) const </td></tr>
<tr class="memdesc:a3c72f6b7162c3c2155268fe47b8b6fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy the substring consisting of at most n characters starting at position pos of the current string.  <a href="#a3c72f6b7162c3c2155268fe47b8b6fda">More...</a><br/></td></tr>
<tr class="separator:a3c72f6b7162c3c2155268fe47b8b6fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6c359cb36afc09bbd296358da597ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aec6c359cb36afc09bbd296358da597ce">swap</a> (<a class="el" href="classOFString.html">OFString</a> &amp;s)</td></tr>
<tr class="memdesc:aec6c359cb36afc09bbd296358da597ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps the contents of the two strings.  <a href="#aec6c359cb36afc09bbd296358da597ce">More...</a><br/></td></tr>
<tr class="separator:aec6c359cb36afc09bbd296358da597ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a787ce241434ec0ef943156e4fe1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ad80a787ce241434ec0ef943156e4fe1a">compare</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str) const </td></tr>
<tr class="memdesc:ad80a787ce241434ec0ef943156e4fe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the effective length rlen of the strings to compare as the smallest of <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> and str.size().  <a href="#ad80a787ce241434ec0ef943156e4fe1a">More...</a><br/></td></tr>
<tr class="separator:ad80a787ce241434ec0ef943156e4fe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd2b56f28ef53eb5900afc9d217d47c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5bd2b56f28ef53eb5900afc9d217d47c">compare</a> (size_t pos1, size_t n1, const <a class="el" href="classOFString.html">OFString</a> &amp;str) const </td></tr>
<tr class="memdesc:a5bd2b56f28ef53eb5900afc9d217d47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from this object and compares it with the input string  <a href="#a5bd2b56f28ef53eb5900afc9d217d47c">More...</a><br/></td></tr>
<tr class="separator:a5bd2b56f28ef53eb5900afc9d217d47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50998bcd4e2696dea426b6457d2a0803"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a50998bcd4e2696dea426b6457d2a0803">compare</a> (size_t pos1, size_t n1, const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos2, size_t n2) const </td></tr>
<tr class="memdesc:a50998bcd4e2696dea426b6457d2a0803"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from this object and another temporary from the input and compares the two temporaries  <a href="#a50998bcd4e2696dea426b6457d2a0803">More...</a><br/></td></tr>
<tr class="separator:a50998bcd4e2696dea426b6457d2a0803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2458b5a0ad81cae868214816a6ded539"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a2458b5a0ad81cae868214816a6ded539">compare</a> (const char *s) const </td></tr>
<tr class="memdesc:a2458b5a0ad81cae868214816a6ded539"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from the input and compares it with the current string  <a href="#a2458b5a0ad81cae868214816a6ded539">More...</a><br/></td></tr>
<tr class="separator:a2458b5a0ad81cae868214816a6ded539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5698d27476fb3118301faebf499fa67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ab5698d27476fb3118301faebf499fa67">compare</a> (size_t pos1, size_t n1, const char *s, size_t n2=OFString_npos) const </td></tr>
<tr class="memdesc:ab5698d27476fb3118301faebf499fa67"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a temporary string from this object and another temporary from the input and compares the two temporaries  <a href="#ab5698d27476fb3118301faebf499fa67">More...</a><br/></td></tr>
<tr class="separator:ab5698d27476fb3118301faebf499fa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3692e0cac9c8342f4fd305ffb2d06960"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a3692e0cac9c8342f4fd305ffb2d06960">find</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;pattern, size_t pos=0) const </td></tr>
<tr class="memdesc:a3692e0cac9c8342f4fd305ffb2d06960"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the earliest occurrence of the input pattern in the current string object, starting from position pos in the current string.  <a href="#a3692e0cac9c8342f4fd305ffb2d06960">More...</a><br/></td></tr>
<tr class="separator:a3692e0cac9c8342f4fd305ffb2d06960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeee89fb230df741435df8cefe8f1a2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a7aeee89fb230df741435df8cefe8f1a2">find</a> (const char *pattern, size_t pos, size_t n) const </td></tr>
<tr class="memdesc:a7aeee89fb230df741435df8cefe8f1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a pattern string from the input and determines the earliest occurrence of the pattern in the current string object, starting from position pos in the current string.  <a href="#a7aeee89fb230df741435df8cefe8f1a2">More...</a><br/></td></tr>
<tr class="separator:a7aeee89fb230df741435df8cefe8f1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c3f3f4f20829691d172c99e7df4b96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a91c3f3f4f20829691d172c99e7df4b96">find</a> (const char *pattern, size_t pos=0) const </td></tr>
<tr class="memdesc:a91c3f3f4f20829691d172c99e7df4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a pattern string from the input and determines the earliest occurrence of the pattern in the current string object, starting from position pos in the current string.  <a href="#a91c3f3f4f20829691d172c99e7df4b96">More...</a><br/></td></tr>
<tr class="separator:a91c3f3f4f20829691d172c99e7df4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e904e9a1fba3ea51522f109da9528e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#af0e904e9a1fba3ea51522f109da9528e">find</a> (char pattern, size_t pos=0) const </td></tr>
<tr class="memdesc:af0e904e9a1fba3ea51522f109da9528e"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a pattern string from the input and determines the earliest occurrence of the pattern in the current string object, starting from position pos in the current string.  <a href="#af0e904e9a1fba3ea51522f109da9528e">More...</a><br/></td></tr>
<tr class="separator:af0e904e9a1fba3ea51522f109da9528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af9d61351df01937612ee1ab0a52fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a49af9d61351df01937612ee1ab0a52fd">rfind</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;pattern, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:a49af9d61351df01937612ee1ab0a52fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string backwards, and finds the first occurrence of pattern in the string (from the back).  <a href="#a49af9d61351df01937612ee1ab0a52fd">More...</a><br/></td></tr>
<tr class="separator:a49af9d61351df01937612ee1ab0a52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d081a3d66f8cdb53bf3ef510adea29b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a8d081a3d66f8cdb53bf3ef510adea29b">rfind</a> (const char *pattern, size_t pos, size_t n) const </td></tr>
<tr class="memdesc:a8d081a3d66f8cdb53bf3ef510adea29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string backwards, and finds the first occurrence of pattern in the string (from the back).  <a href="#a8d081a3d66f8cdb53bf3ef510adea29b">More...</a><br/></td></tr>
<tr class="separator:a8d081a3d66f8cdb53bf3ef510adea29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c68dfba3ae3857a50a7616247c97bec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a1c68dfba3ae3857a50a7616247c97bec">rfind</a> (const char *pattern, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:a1c68dfba3ae3857a50a7616247c97bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string backwards, and finds the first occurrence of pattern in the string (from the back).  <a href="#a1c68dfba3ae3857a50a7616247c97bec">More...</a><br/></td></tr>
<tr class="separator:a1c68dfba3ae3857a50a7616247c97bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cfd41efb41e5aa4720e44e209304a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#af4cfd41efb41e5aa4720e44e209304a5">rfind</a> (char pattern, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:af4cfd41efb41e5aa4720e44e209304a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string backwards, and finds the first occurrence of pattern in the string (from the back).  <a href="#af4cfd41efb41e5aa4720e44e209304a5">More...</a><br/></td></tr>
<tr class="separator:af4cfd41efb41e5aa4720e44e209304a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b48ba05f724d443c128b3e8a3e0cdc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ac7b48ba05f724d443c128b3e8a3e0cdc">find_first_of</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos=0) const </td></tr>
<tr class="memdesc:ac7b48ba05f724d443c128b3e8a3e0cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location, loc, between pos and the end of the current string, such that the character at loc matches at least one character from the set of characters.  <a href="#ac7b48ba05f724d443c128b3e8a3e0cdc">More...</a><br/></td></tr>
<tr class="separator:ac7b48ba05f724d443c128b3e8a3e0cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fb8c28772e2f828d3e21d5b44f2b74"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a30fb8c28772e2f828d3e21d5b44f2b74">find_first_of</a> (const char *s, size_t pos, size_t n) const </td></tr>
<tr class="memdesc:a30fb8c28772e2f828d3e21d5b44f2b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location, loc, between pos and the end of the current string, such that the character at loc matches at least one character from the set of characters.  <a href="#a30fb8c28772e2f828d3e21d5b44f2b74">More...</a><br/></td></tr>
<tr class="separator:a30fb8c28772e2f828d3e21d5b44f2b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0fd040a8d69338c8527ff2f2d941d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a1d0fd040a8d69338c8527ff2f2d941d2">find_first_of</a> (const char *s, size_t pos=0) const </td></tr>
<tr class="memdesc:a1d0fd040a8d69338c8527ff2f2d941d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location, loc, between pos and the end of the current string, such that the character at loc matches at least one character from the set of characters.  <a href="#a1d0fd040a8d69338c8527ff2f2d941d2">More...</a><br/></td></tr>
<tr class="separator:a1d0fd040a8d69338c8527ff2f2d941d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fdf90b160b8bf551f68d0fdad33651"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a92fdf90b160b8bf551f68d0fdad33651">find_first_of</a> (char s, size_t pos=0) const </td></tr>
<tr class="memdesc:a92fdf90b160b8bf551f68d0fdad33651"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location, loc, between pos and the end of the current string, such that the character at loc matches the given character.  <a href="#a92fdf90b160b8bf551f68d0fdad33651">More...</a><br/></td></tr>
<tr class="separator:a92fdf90b160b8bf551f68d0fdad33651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b77efcdaea4f2ef24ac627f67d75f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ae6b77efcdaea4f2ef24ac627f67d75f4">find_last_of</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:ae6b77efcdaea4f2ef24ac627f67d75f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the highest location, loc, up to pos, such that the character at loc matches at least one character from the set of characters.  <a href="#ae6b77efcdaea4f2ef24ac627f67d75f4">More...</a><br/></td></tr>
<tr class="separator:ae6b77efcdaea4f2ef24ac627f67d75f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87304af7da4f0c7e5dfbd8162093f28"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ae87304af7da4f0c7e5dfbd8162093f28">find_last_of</a> (const char *s, size_t pos, size_t n) const </td></tr>
<tr class="memdesc:ae87304af7da4f0c7e5dfbd8162093f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the highest location, loc, up to pos, such that the character at loc matches at least one character from the set of characters.  <a href="#ae87304af7da4f0c7e5dfbd8162093f28">More...</a><br/></td></tr>
<tr class="separator:ae87304af7da4f0c7e5dfbd8162093f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdfafdec6f6f464b4c9082ff3cf3173"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#accdfafdec6f6f464b4c9082ff3cf3173">find_last_of</a> (const char *s, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:accdfafdec6f6f464b4c9082ff3cf3173"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the highest location, loc, up to pos, such that the character at loc matches at least one character from the set of characters.  <a href="#accdfafdec6f6f464b4c9082ff3cf3173">More...</a><br/></td></tr>
<tr class="separator:accdfafdec6f6f464b4c9082ff3cf3173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f5bc59147636a8d2d7dc4623518dce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#af0f5bc59147636a8d2d7dc4623518dce">find_last_of</a> (char s, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:af0f5bc59147636a8d2d7dc4623518dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the highest location, loc, up to pos, such that the character at loc matches the given character.  <a href="#af0f5bc59147636a8d2d7dc4623518dce">More...</a><br/></td></tr>
<tr class="separator:af0f5bc59147636a8d2d7dc4623518dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae662823bd3905eb8b9ac7d8548fa7608"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ae662823bd3905eb8b9ac7d8548fa7608">find_first_not_of</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos=0) const </td></tr>
<tr class="memdesc:ae662823bd3905eb8b9ac7d8548fa7608"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location loc, between pos and the end of the current string, such that the character at loc does not match any character from the set of characters.  <a href="#ae662823bd3905eb8b9ac7d8548fa7608">More...</a><br/></td></tr>
<tr class="separator:ae662823bd3905eb8b9ac7d8548fa7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa290ba8b18e92bddc8dde78784eb0a60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#aa290ba8b18e92bddc8dde78784eb0a60">find_first_not_of</a> (const char *s, size_t pos, size_t n) const </td></tr>
<tr class="memdesc:aa290ba8b18e92bddc8dde78784eb0a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location loc, between pos and the end of the current string, such that the character at loc does not match any character from the set of characters.  <a href="#aa290ba8b18e92bddc8dde78784eb0a60">More...</a><br/></td></tr>
<tr class="separator:aa290ba8b18e92bddc8dde78784eb0a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067f1b231b25570e9561a56255e397db"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a067f1b231b25570e9561a56255e397db">find_first_not_of</a> (const char *s, size_t pos=0) const </td></tr>
<tr class="memdesc:a067f1b231b25570e9561a56255e397db"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location loc, between pos and the end of the current string, such that the character at loc does not match any character from the set of characters.  <a href="#a067f1b231b25570e9561a56255e397db">More...</a><br/></td></tr>
<tr class="separator:a067f1b231b25570e9561a56255e397db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064a62b8db088840f792a7168afd80f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a064a62b8db088840f792a7168afd80f1">find_first_not_of</a> (char c, size_t pos=0) const </td></tr>
<tr class="memdesc:a064a62b8db088840f792a7168afd80f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the first location loc, between pos and the end of the current string, such that the character at loc does not match the given character.  <a href="#a064a62b8db088840f792a7168afd80f1">More...</a><br/></td></tr>
<tr class="separator:a064a62b8db088840f792a7168afd80f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cbf9af93ec6980e426195d7b668087"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a24cbf9af93ec6980e426195d7b668087">find_last_not_of</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;str, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:a24cbf9af93ec6980e426195d7b668087"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match any character from the set of characters.  <a href="#a24cbf9af93ec6980e426195d7b668087">More...</a><br/></td></tr>
<tr class="separator:a24cbf9af93ec6980e426195d7b668087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aae4a4469fdc6a16aff69de4ea58c12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a8aae4a4469fdc6a16aff69de4ea58c12">find_last_not_of</a> (const char *s, size_t pos, size_t n) const </td></tr>
<tr class="memdesc:a8aae4a4469fdc6a16aff69de4ea58c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match any character from the set of characters.  <a href="#a8aae4a4469fdc6a16aff69de4ea58c12">More...</a><br/></td></tr>
<tr class="separator:a8aae4a4469fdc6a16aff69de4ea58c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a4bd1baaa8754d7f1fc4b6c71c52c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a011a4bd1baaa8754d7f1fc4b6c71c52c">find_last_not_of</a> (const char *s, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:a011a4bd1baaa8754d7f1fc4b6c71c52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match any character from the set of characters.  <a href="#a011a4bd1baaa8754d7f1fc4b6c71c52c">More...</a><br/></td></tr>
<tr class="separator:a011a4bd1baaa8754d7f1fc4b6c71c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a770e869eb5f231927c8d973656f20a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a0a770e869eb5f231927c8d973656f20a">find_last_not_of</a> (char c, size_t pos=OFString_npos) const </td></tr>
<tr class="memdesc:a0a770e869eb5f231927c8d973656f20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match the given character.  <a href="#a0a770e869eb5f231927c8d973656f20a">More...</a><br/></td></tr>
<tr class="separator:a0a770e869eb5f231927c8d973656f20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c277867cf6bb5dbb1d93a573815223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html#a1b6e1b66f6870d74b0cd281fa2cb6157">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ad7c277867cf6bb5dbb1d93a573815223">begin</a> () const </td></tr>
<tr class="memdesc:ad7c277867cf6bb5dbb1d93a573815223"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a constant iterator that points to the beginning of the string  <a href="#ad7c277867cf6bb5dbb1d93a573815223">More...</a><br/></td></tr>
<tr class="separator:ad7c277867cf6bb5dbb1d93a573815223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97434673a44783bdc758ecff484b25cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFString.html#a1b6e1b66f6870d74b0cd281fa2cb6157">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a97434673a44783bdc758ecff484b25cc">end</a> () const </td></tr>
<tr class="memdesc:a97434673a44783bdc758ecff484b25cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a constant iterator that points after the last element of the string  <a href="#a97434673a44783bdc758ecff484b25cc">More...</a><br/></td></tr>
<tr class="separator:a97434673a44783bdc758ecff484b25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac8cbcd1290872dc708fd010ca07ff4d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8cbcd1290872dc708fd010ca07ff4d3"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#ac8cbcd1290872dc708fd010ca07ff4d3">theCString</a></td></tr>
<tr class="memdesc:ac8cbcd1290872dc708fd010ca07ff4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the "C" string pointer <br/></td></tr>
<tr class="separator:ac8cbcd1290872dc708fd010ca07ff4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b278e5aba0070a97816e92217c8e01d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b278e5aba0070a97816e92217c8e01d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a5b278e5aba0070a97816e92217c8e01d">theSize</a></td></tr>
<tr class="memdesc:a5b278e5aba0070a97816e92217c8e01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the length of theCString <br/></td></tr>
<tr class="separator:a5b278e5aba0070a97816e92217c8e01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ac83f2c4f0ec6497a7575d949e459"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a498ac83f2c4f0ec6497a7575d949e459"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFString.html#a498ac83f2c4f0ec6497a7575d949e459">theCapacity</a></td></tr>
<tr class="memdesc:a498ac83f2c4f0ec6497a7575d949e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">the capacity of str <br/></td></tr>
<tr class="separator:a498ac83f2c4f0ec6497a7575d949e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>a simple string class that implements a subset of std::string. </p>
<p>It does not implement iterators or traits and is not optimized for speed. </p>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00086">86</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1b6e1b66f6870d74b0cd281fa2cb6157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const char* <a class="el" href="classOFString.html#a1b6e1b66f6870d74b0cd281fa2cb6157">OFString::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this typedef can be used to iterate over an string. </p>
<p>Note: Normally you are allowed to modify items through an iterator, we do not allow this! </p>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00818">818</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2f9197dbfa6e51669cfdeae9f6002667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OFString::OFString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty string. </p>

</div>
</div>
<a class="anchor" id="aaa14142b6a4e2d5de21029600bf19885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OFString::OFString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a string from the given input string str. </p>
<p>The effective length rlen of the constructed string is the smaller of n and str.size() - pos, and the string is constructed by copying rlen characters starting at position pos of the input string str. The function throws an out-of-range error if pos &gt; str.size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to copy from </td></tr>
    <tr><td class="paramname">pos</td><td>position to start copying from </td></tr>
    <tr><td class="paramname">n</td><td>maximum number of characters to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9bf7c011bb848908dbdc456af47c5c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OFString::OFString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constructor copies n characters starting at s, and constructs a string object initialized with the corresponding characters. </p>
<p>NOTE: If n &gt; length(s), then junk characters are appended to the end of the string. i.e. n characters are copied regardless of the exact length of the array pointed to by the input pointer s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f57d27ca9355904c5d43709e3da7354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OFString::OFString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a string object from the array pointed to by the input pointer s. </p>
<p>It is assumed that s is not a null pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2f3b0b39a7a65d366114dff77acb46d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OFString::OFString </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a string object with the character c repeated rep times. </p>
<p>Reports a length error if rep equals npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>number of repetitions </td></tr>
    <tr><td class="paramname">c</td><td>character to construct from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac67028a957b5ff4b31511981c76d559f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends characters from the input string str to the current string object. </p>
<p>At most n characters, starting at position pos of str, are appended. The function reports an out-of-range error if pos &gt; str.size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append from </td></tr>
    <tr><td class="paramname">pos</td><td>position to start copying from </td></tr>
    <tr><td class="paramname">n</td><td>maximum number of characters to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a1a6e455389dc7d40ec7a358c8be4ba76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and appends it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="ab1854bb074f5ac64e4130bb8f5f2dbf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and appends it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a649aa6dd2eaca33881abb0e9075d5b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::append </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and appends it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>number of repetitions </td></tr>
    <tr><td class="paramname">c</td><td>character to construct from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a3d5e1ff5ab7833cee1cca6b3b42cda3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns characters from the input string str to the current string object. </p>
<p>At most n characters, starting at position pos of str, are appended. The function reports an out-of-range error if pos &gt; str.size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to append from </td></tr>
    <tr><td class="paramname">pos</td><td>position to start copying from </td></tr>
    <tr><td class="paramname">n</td><td>maximum number of characters to copy, can be OFString_npos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a34b454d16e5db4985a4b678c0bc45560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns input string str to the current string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5c19d55c5a7002c62d66b8d80b559b93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and assigns it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="aa5d8707b22e143255db1e341ed749ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and assigns it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a8fa7553c7040cde61b15883331c64ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::assign </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and assigns it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>number of repetitions </td></tr>
    <tr><td class="paramname">c</td><td>character to construct from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5ce83e87b2c25c10375bb86271f51826"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char&amp; OFString::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a constant reference to the character at position pos of the current string. </p>
<p>if pos &gt;= <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>, throws out_of_range exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const reference to character in string at pos </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00342">342</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00410">size()</a>, and <a class="el" href="ofstring_8h_source.html#l00835">theCString</a>.</p>

</div>
</div>
<a class="anchor" id="a80b86f83b7fb166275ebfdbbe983fb9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; OFString::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a non-const reference to the character at position pos of the current string. </p>
<p>if pos &gt;= <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>, throws out_of_range exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-const reference to character in string at pos </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00354">354</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00410">size()</a>, and <a class="el" href="ofstring_8h_source.html#l00835">theCString</a>.</p>

</div>
</div>
<a class="anchor" id="ad7c277867cf6bb5dbb1d93a573815223"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html#a1b6e1b66f6870d74b0cd281fa2cb6157">iterator</a> OFString::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a constant iterator that points to the beginning of the string </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the beginning of the string </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00826">826</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00835">theCString</a>.</p>

<p>Referenced by <a class="el" href="ofstring_8h_source.html#l00831">end()</a>.</p>

</div>
</div>
<a class="anchor" id="a82f2afbb21f305a5b1b4ec62ec9dc4bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* OFString::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a pointer to the initial element of an array of length <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>+1 whose first <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> elements equal the corresponding elements of the current string and whose last element is a null character. </p>
<dl class="section return"><dt>Returns</dt><dd>C string for this string </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00392">392</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00835">theCString</a>.</p>

<p>Referenced by <a class="el" href="dccfuidh_8h_source.html#l00095">DcmUIDHandler::c_str()</a>, <a class="el" href="dviface_8h_source.html#l01418">DVInterface::getAnnotationText()</a>, <a class="el" href="dvpscu_8h_source.html#l00113">DVPSCurve::getCurveAxisUnitsX()</a>, <a class="el" href="dvpscu_8h_source.html#l00119">DVPSCurve::getCurveAxisUnitsY()</a>, <a class="el" href="dvpscu_8h_source.html#l00101">DVPSCurve::getCurveDescription()</a>, <a class="el" href="dvpscu_8h_source.html#l00107">DVPSCurve::getCurveLabel()</a>, <a class="el" href="diovpln_8h_source.html#l00349">DiOverlayPlane::getDescription()</a>, <a class="el" href="dibaslut_8h_source.html#l00247">DiBaseLUT::getExplanation()</a>, <a class="el" href="dvcache_8h_source.html#l00316">DVInstanceCache::getFilename()</a>, <a class="el" href="ofconfig_8h_source.html#l00092">OFConfigFileNode::getKeyword()</a>, <a class="el" href="diovpln_8h_source.html#l00340">DiOverlayPlane::getLabel()</a>, <a class="el" href="didocu_8h_source.html#l00171">DiDocument::getPhotometricInterpretation()</a>, <a class="el" href="dccfpcmp_8h_source.html#l00084">DcmPresentationContextItem::getTransferSyntaxKey()</a>, <a class="el" href="dvpsfs_8h_source.html#l00132">DVPSFilmSession::getUID()</a>, <a class="el" href="ofconfig_8h_source.html#l00099">OFConfigFileNode::getValue()</a>, and <a class="el" href="dimoimg_8h_source.html#l00335">DiMonoImage::getVoiTransformationExplanation()</a>.</p>

</div>
</div>
<a class="anchor" id="a79ce8c967a6e6e3f5afc062104482202"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the size of the allocated storage in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the allocated storage in the string </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00442">442</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00841">theCapacity</a>.</p>

</div>
</div>
<a class="anchor" id="ad80a787ce241434ec0ef943156e4fe1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OFString::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the effective length rlen of the strings to compare as the smallest of <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> and str.size(). </p>
<p>The function then compares the two strings by calling strcmp(<a class="el" href="classOFString.html#a47921917148fe9a39379e52ccbfda83d" title="if size() is nonzero, this function returns a pointer to the initial element of an array whose first ...">data()</a>, str.data(), rlen). Returns: the nonzero result if the result of the comparison is nonzero. Otherwise, returns a value &lt; 0 if <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> &lt; str.size(), a value of 0 if <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> == str.size(), or a value &gt; 0 if <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> &gt; str.size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>comparison result as described above </dd></dl>

</div>
</div>
<a class="anchor" id="a5bd2b56f28ef53eb5900afc9d217d47c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OFString::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from this object and compares it with the input string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>position to start copying from this object </td></tr>
    <tr><td class="paramname">n1</td><td>maximum number of characters to copy from this object </td></tr>
    <tr><td class="paramname">str</td><td>string to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>comparison result </dd></dl>

</div>
</div>
<a class="anchor" id="a50998bcd4e2696dea426b6457d2a0803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OFString::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from this object and another temporary from the input and compares the two temporaries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>position to start copying from this object </td></tr>
    <tr><td class="paramname">n1</td><td>maximum number of characters to copy from this object </td></tr>
    <tr><td class="paramname">str</td><td>string to create second temporary from </td></tr>
    <tr><td class="paramname">pos2</td><td>position to start copying from in str </td></tr>
    <tr><td class="paramname">n2</td><td>maximum number of characters to copy from str </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>comparison result </dd></dl>

</div>
</div>
<a class="anchor" id="a2458b5a0ad81cae868214816a6ded539"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OFString::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and compares it with the current string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>comparison result </dd></dl>

</div>
</div>
<a class="anchor" id="ab5698d27476fb3118301faebf499fa67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OFString::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from this object and another temporary from the input and compares the two temporaries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>position to start copying from this object </td></tr>
    <tr><td class="paramname">n1</td><td>maximum number of characters to copy from this object </td></tr>
    <tr><td class="paramname">s</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">n2</td><td>number of characters in array s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>comparison result </dd></dl>

</div>
</div>
<a class="anchor" id="aa3599179906f759d794685b529e76e8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replaces the string designated by s with a copy of a range of characters from the current string. </p>
<p>The range copied begins at position pos of the current string and extends for n characters or up to the end of the current string, whichever comes first. Does not append a null object to the end of the string designated by s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character array to copy to </td></tr>
    <tr><td class="paramname">n</td><td>size of character array </td></tr>
    <tr><td class="paramname">pos</td><td>position in string to start copying from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters copied </dd></dl>

</div>
</div>
<a class="anchor" id="a47921917148fe9a39379e52ccbfda83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OFString::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> is nonzero, this function returns a pointer to the initial element of an array whose first <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> elements equal the corresponding elements of the string controlled by *this. </p>
<p>If <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a> is zero, the member returns a non-null pointer that is copyable and can have zero added to it. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to char array for this string </dd></dl>

</div>
</div>
<a class="anchor" id="a5bb19c72ef402a019368731cc5615b9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFString::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if the string is empty, false otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the string is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00427">427</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00410">size()</a>.</p>

<p>Referenced by <a class="el" href="diinpxt_8h_source.html#l00358">DiInputPixelTemplate&lt; T1, T2 &gt;::convert()</a>, <a class="el" href="diovpln_8h_source.html#l00349">DiOverlayPlane::getDescription()</a>, <a class="el" href="dibaslut_8h_source.html#l00247">DiBaseLUT::getExplanation()</a>, and <a class="el" href="diovpln_8h_source.html#l00340">DiOverlayPlane::getLabel()</a>.</p>

</div>
</div>
<a class="anchor" id="a97434673a44783bdc758ecff484b25cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html#a1b6e1b66f6870d74b0cd281fa2cb6157">iterator</a> OFString::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a constant iterator that points after the last element of the string </p>
<dl class="section return"><dt>Returns</dt><dd>iterator after the last element of the string </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00831">831</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00826">begin()</a>, and <a class="el" href="ofstring_8h_source.html#l00419">length()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f8e79ca185d93f6a089c57ac58748fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes up to n characters from the string starting from position pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to start from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

<p>Referenced by <a class="el" href="ofstring_8h_source.html#l00457">clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a3692e0cac9c8342f4fd305ffb2d06960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the earliest occurrence of the input pattern in the current string object, starting from position pos in the current string. </p>
<p>If find can determine such an occurrence, it returns the starting index of pattern in the current string. Otherwise, it returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>pattern to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern as described above </dd></dl>

</div>
</div>
<a class="anchor" id="a7aeee89fb230df741435df8cefe8f1a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a pattern string from the input and determines the earliest occurrence of the pattern in the current string object, starting from position pos in the current string. </p>
<p>If find can determine such an occurrence, it returns the starting index of pattern in the current string. Otherwise, it returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a91c3f3f4f20829691d172c99e7df4b96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a pattern string from the input and determines the earliest occurrence of the pattern in the current string object, starting from position pos in the current string. </p>
<p>If find can determine such an occurrence, it returns the starting index of pattern in the current string. Otherwise, it returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="af0e904e9a1fba3ea51522f109da9528e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a pattern string from the input and determines the earliest occurrence of the pattern in the current string object, starting from position pos in the current string. </p>
<p>If find can determine such an occurrence, it returns the starting index of pattern in the current string. Otherwise, it returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>character </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="ae662823bd3905eb8b9ac7d8548fa7608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location loc, between pos and the end of the current string, such that the character at loc does not match any character from the set of characters. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>set of characters to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character as described above </dd></dl>

</div>
</div>
<a class="anchor" id="aa290ba8b18e92bddc8dde78784eb0a60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location loc, between pos and the end of the current string, such that the character at loc does not match any character from the set of characters. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a067f1b231b25570e9561a56255e397db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location loc, between pos and the end of the current string, such that the character at loc does not match any character from the set of characters. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to a zero-terminated C string. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a064a62b8db088840f792a7168afd80f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location loc, between pos and the end of the current string, such that the character at loc does not match the given character. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>character to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character </dd></dl>

</div>
</div>
<a class="anchor" id="ac7b48ba05f724d443c128b3e8a3e0cdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location, loc, between pos and the end of the current string, such that the character at loc matches at least one character from the set of characters. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>set of characters to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character as described above </dd></dl>

</div>
</div>
<a class="anchor" id="a30fb8c28772e2f828d3e21d5b44f2b74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location, loc, between pos and the end of the current string, such that the character at loc matches at least one character from the set of characters. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a1d0fd040a8d69338c8527ff2f2d941d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location, loc, between pos and the end of the current string, such that the character at loc matches at least one character from the set of characters. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to a zero-terminated C string. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a92fdf90b160b8bf551f68d0fdad33651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the first location, loc, between pos and the end of the current string, such that the character at loc matches the given character. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character </dd></dl>

</div>
</div>
<a class="anchor" id="a24cbf9af93ec6980e426195d7b668087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match any character from the set of characters. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>set of characters to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character as described above </dd></dl>

</div>
</div>
<a class="anchor" id="a8aae4a4469fdc6a16aff69de4ea58c12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match any character from the set of characters. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a011a4bd1baaa8754d7f1fc4b6c71c52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match any character from the set of characters. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to a zero-terminated C string. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a0a770e869eb5f231927c8d973656f20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string up to the position pos and determines the highest location, loc, such that the character at loc does not match the given character. </p>
<p>If such a location is found, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>character to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character </dd></dl>

</div>
</div>
<a class="anchor" id="ae6b77efcdaea4f2ef24ac627f67d75f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the highest location, loc, up to pos, such that the character at loc matches at least one character from the set of characters. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>set of characters to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character as described above </dd></dl>

</div>
</div>
<a class="anchor" id="ae87304af7da4f0c7e5dfbd8162093f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the highest location, loc, up to pos, such that the character at loc matches at least one character from the set of characters. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="accdfafdec6f6f464b4c9082ff3cf3173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the highest location, loc, up to pos, such that the character at loc matches at least one character from the set of characters. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>set of characters to find, pointer to a zero-terminated C string. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="af0f5bc59147636a8d2d7dc4623518dce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the highest location, loc, up to pos, such that the character at loc matches the given character. </p>
<p>If such a location can be determined, it is returned. Otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of character </dd></dl>

</div>
</div>
<a class="anchor" id="a89263f9aff57699a38e359b080bd8d95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts at most n characters, starting at position pos2 of the input string str, into the current string. </p>
<p>The characters are inserted starting at position pos1 in the current string. The function reports an out-of-range error if pos &gt; str.size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>position to insert at </td></tr>
    <tr><td class="paramname">str</td><td>string to copy from </td></tr>
    <tr><td class="paramname">pos2</td><td>position to start copying from </td></tr>
    <tr><td class="paramname">n</td><td>maximum number of characters to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a701cd6c7bf08768affcbadc23ee96290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and inserts it into the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert at </td></tr>
    <tr><td class="paramname">s</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="aaf8a365f2f07a962b6199e60d5de6f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and inserts it into the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert at </td></tr>
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="ac39855574592774a02c8f0bfba2fae77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and inserts it into the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert at </td></tr>
    <tr><td class="paramname">rep</td><td>number of repetitions </td></tr>
    <tr><td class="paramname">c</td><td>character to construct from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="ac614bab6a5df1a1af381071bdf3128f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a count of the number of char-like objects currently in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>number of char-like objects currently in string </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00419">419</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00410">size()</a>.</p>

<p>Referenced by <a class="el" href="ofstring_8h_source.html#l00831">end()</a>.</p>

</div>
</div>
<a class="anchor" id="a7673cf5e31c1542a2a140540c1dc664b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the maximum size of a string which could possibly by allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>maximum size of a string which could possibly by allocated. </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00450">450</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5a13c8574752c26838e61ddc8469b329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the input string to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>string to append from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5bd888544a2c4d9febfe9d769cf839f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input s and appends it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="aae66af336e6670ff83364c6c8424150b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::operator+= </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input s and appends it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5da022549921156b66a7c7c79ae3dae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assigns the input string to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>string to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5503a30883b45f4463cb457b0e7dd866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input s and assigns it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a03b3a312bfe55d33edc807da60bf5882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::operator= </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input s and assigns it to the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a4a2614b9d7a5d0ba6a349de35a1d541c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char OFString::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the element at position pos of the current string. </p>
<p>Returns '\0' if pos == <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>character in string at pos (by value) </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00365">365</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00410">size()</a>, and <a class="el" href="ofstring_8h_source.html#l00835">theCString</a>.</p>

</div>
</div>
<a class="anchor" id="aae05a9c93953f63531c20d0f0c5c1b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; OFString::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the element at position pos of the current string. </p>
<p>The reference returned is invalid after a subsequent call to any non-const member function for the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in string, must be &lt; <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>character in string at pos (by reference) </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00381">381</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00410">size()</a>, and <a class="el" href="ofstring_8h_source.html#l00835">theCString</a>.</p>

</div>
</div>
<a class="anchor" id="adb618591e2ad33202d5b505ffd06445f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replaces a range of characters in the current string with a range of characters taken from the input string str. </p>
<p>The range to be replaced starts at position pos1 in the current string, and extends for n1 characters, or up to the end of the string, whichever comes first. The range of characters inserted starts at position pos2 of the input string str, and extends for n2 characters, or up to the end of the string str, whichever comes first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>position to insert at </td></tr>
    <tr><td class="paramname">n1</td><td>number of characters to replace </td></tr>
    <tr><td class="paramname">str</td><td>string to copy from </td></tr>
    <tr><td class="paramname">pos2</td><td>position to start copying from </td></tr>
    <tr><td class="paramname">n2</td><td>maximum number of characters to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a868371ad7a8273594f6ff651e4548889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and replaces the range [pos, n] in the current string with the constructed string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to replace at </td></tr>
    <tr><td class="paramname">n</td><td>number of characters to be replaced </td></tr>
    <tr><td class="paramname">s</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">n2</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a89c92b4ff869e09c9cfc0492e80fb523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and replaces the range [pos, n] in the current string with the constructed string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to replace at </td></tr>
    <tr><td class="paramname">n</td><td>number of characters to be replaced </td></tr>
    <tr><td class="paramname">s</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a3fc425dc9e2bd4484489fcd304837f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a>&amp; OFString::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a temporary string from the input and replaces the range [pos, n] in the current string with the constructed string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to replace at </td></tr>
    <tr><td class="paramname">n</td><td>number of characters to be replaced </td></tr>
    <tr><td class="paramname">rep</td><td>number of repetitions </td></tr>
    <tr><td class="paramname">s</td><td>character to construct from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="aeb5b3854ae3bfdd323ebfda499ed5001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OFString::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>res_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>directive that informs a string of a planned change in size, so that it can manage the storage allocation accordingly. </p>
<p>Reallocation of a string happens if and only if the current capacity is less than res_arg. After this call, <a class="el" href="classOFString.html#a79ce8c967a6e6e3f5afc062104482202" title="returns the size of the allocated storage in the string.">capacity()</a> is greater than or equal to res_arg if reallocation happens and equal to the previous value of <a class="el" href="classOFString.html#a79ce8c967a6e6e3f5afc062104482202" title="returns the size of the allocated storage in the string.">capacity()</a> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_arg</td><td>string capacity to reserve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae62da8f78dee4485804cba6b0b75c613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OFString::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em> = <code>'\0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if n &lt;= <a class="el" href="classOFString.html#aaa3a81790b4a9a4787ddf7c93ad5051e" title="returns a count of the number of char-like objects currently in the string.">size()</a>, truncates the string to length n else it pads the extra locations with c. </p>
<p>Reports a length error if n equals OFString_npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>length to truncate string to </td></tr>
    <tr><td class="paramname">c</td><td>character to pad extra locations with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49af9d61351df01937612ee1ab0a52fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string backwards, and finds the first occurrence of pattern in the string (from the back). </p>
<p>The starting index of the matched position in the current string should be less than or equal to the parameter pos. If a match is found, the starting index is returned; otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>pattern to find </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern as described above </dd></dl>

</div>
</div>
<a class="anchor" id="a8d081a3d66f8cdb53bf3ef510adea29b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::rfind </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string backwards, and finds the first occurrence of pattern in the string (from the back). </p>
<p>The starting index of the matched position in the current string should be less than or equal to the parameter pos. If a match is found, the starting index is returned; otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>pointer to an array of char of length n. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="a1c68dfba3ae3857a50a7616247c97bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::rfind </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string backwards, and finds the first occurrence of pattern in the string (from the back). </p>
<p>The starting index of the matched position in the current string should be less than or equal to the parameter pos. If a match is found, the starting index is returned; otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>pointer to a zero-terminated C string. Must not be NULL. </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="af4cfd41efb41e5aa4720e44e209304a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::rfind </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scans the current string backwards, and finds the first occurrence of pattern in the string (from the back). </p>
<p>The starting index of the matched position in the current string should be less than or equal to the parameter pos. If a match is found, the starting index is returned; otherwise, the function returns string::npos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>character </td></tr>
    <tr><td class="paramname">pos</td><td>position to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of pattern in string </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3a81790b4a9a4787ddf7c93ad5051e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFString::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a count of the number of char-like objects currently in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>number of char-like objects currently in string </dd></dl>

<p>Definition at line <a class="el" href="ofstring_8h_source.html#l00410">410</a> of file <a class="el" href="ofstring_8h_source.html">ofstring.h</a>.</p>

<p>References <a class="el" href="ofstring_8h_source.html#l00838">theSize</a>.</p>

<p>Referenced by <a class="el" href="ofstring_8h_source.html#l00342">at()</a>, <a class="el" href="ofstring_8h_source.html#l00427">empty()</a>, <a class="el" href="ofstring_8h_source.html#l00419">length()</a>, and <a class="el" href="ofstring_8h_source.html#l00365">operator[]()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c72f6b7162c3c2155268fe47b8b6fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFString.html">OFString</a> OFString::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>OFString_npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a copy the substring consisting of at most n characters starting at position pos of the current string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position in string to start copying from </td></tr>
    <tr><td class="paramname">n</td><td>number of characters to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec6c359cb36afc09bbd296358da597ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OFString::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swaps the contents of the two strings. </p>
<p>The time complexity of this function is linear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>F:/Projects/GigaVoxels/Livraison_GV/ThirdDependencies/windows-VS2013-x64/dcmtk-3.6.0_VS2013/ofstd/include/dcmtk/ofstd/<a class="el" href="ofstring_8h_source.html">ofstring.h</a></li>
</ul>
</div><!-- contents -->
<p>
<hr>
<small>
Generated on Thu Jul 23 2015 for <a href="http://dicom.offis.de/dcmtk">OFFIS DCMTK</a> Version 3.6.0 by <a href="http://www.doxygen.org/">Doxygen</a> 1.8.3.1
</small>
