<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OFFIS DCMTK: OFStandard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OFFIS DCMTK
   &#160;<span id="projectnumber">Version 3.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classOFStandard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OFStandard Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for various helper functions.  
 <a href="classOFStandard.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ada06320031143da5f04f68826f7b5b3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a> { <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faea5ae864481ee16f0a99da4fea78715d">MM_HTML</a>, 
<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3fa47e3f34b8f31923b7d7968c0ab5cb7e7">MM_HTML32</a>, 
<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3fa802ef3634b97b4fad9effb1955463dcc">MM_XHTML</a>, 
<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a>
 }</td></tr>
<tr class="memdesc:ada06320031143da5f04f68826f7b5b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Markup language mode.  <a href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">More...</a><br/></td></tr>
<tr class="separator:ada06320031143da5f04f68826f7b5b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab3aaaedae7176ef90b36af8cdf7ee648"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ab3aaaedae7176ef90b36af8cdf7ee648">strlcpy</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:ab3aaaedae7176ef90b36af8cdf7ee648"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies up to size - 1 characters from the NUL- terminated string src to dst, NUL-terminating the result.  <a href="#ab3aaaedae7176ef90b36af8cdf7ee648">More...</a><br/></td></tr>
<tr class="separator:ab3aaaedae7176ef90b36af8cdf7ee648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976613403ca9423d19867b22e92fd663"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a976613403ca9423d19867b22e92fd663">strlcat</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:a976613403ca9423d19867b22e92fd663"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function appends the NUL-terminated string src to the end of dst.  <a href="#a976613403ca9423d19867b22e92fd663">More...</a><br/></td></tr>
<tr class="separator:a976613403ca9423d19867b22e92fd663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29b92d97c56b8f42dcdf011abfcf201"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad29b92d97c56b8f42dcdf011abfcf201">strerror</a> (const int errnum, char *buf, const size_t buflen)</td></tr>
<tr class="memdesc:ad29b92d97c56b8f42dcdf011abfcf201"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a given error code to a string.  <a href="#ad29b92d97c56b8f42dcdf011abfcf201">More...</a><br/></td></tr>
<tr class="separator:ad29b92d97c56b8f42dcdf011abfcf201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7a81568899f73c7292f155096d5ef1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a1d7a81568899f73c7292f155096d5ef1">toUpper</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:a1d7a81568899f73c7292f155096d5ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the upper-case version of a given string  <a href="#a1d7a81568899f73c7292f155096d5ef1">More...</a><br/></td></tr>
<tr class="separator:a1d7a81568899f73c7292f155096d5ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a26201452fd4a102edf3f4a719fdc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad83a26201452fd4a102edf3f4a719fdc">toUpper</a> (<a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:ad83a26201452fd4a102edf3f4a719fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the upper-case version of a given string.  <a href="#ad83a26201452fd4a102edf3f4a719fdc">More...</a><br/></td></tr>
<tr class="separator:ad83a26201452fd4a102edf3f4a719fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a21841dc6a358c17415b8422e0084d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a3a21841dc6a358c17415b8422e0084d6">toLower</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:a3a21841dc6a358c17415b8422e0084d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the lower-case version of a given string  <a href="#a3a21841dc6a358c17415b8422e0084d6">More...</a><br/></td></tr>
<tr class="separator:a3a21841dc6a358c17415b8422e0084d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3b699ce3361e253f973c6203a92781"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ade3b699ce3361e253f973c6203a92781">toLower</a> (<a class="el" href="classOFString.html">OFString</a> &amp;value)</td></tr>
<tr class="memdesc:ade3b699ce3361e253f973c6203a92781"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the lower-case version of a given string.  <a href="#ade3b699ce3361e253f973c6203a92781">More...</a><br/></td></tr>
<tr class="separator:ade3b699ce3361e253f973c6203a92781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3d7ff0cd4896773a87ab07cb249835"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a8b3d7ff0cd4896773a87ab07cb249835">pathExists</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;pathName)</td></tr>
<tr class="memdesc:a8b3d7ff0cd4896773a87ab07cb249835"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given path exists.  <a href="#a8b3d7ff0cd4896773a87ab07cb249835">More...</a><br/></td></tr>
<tr class="separator:a8b3d7ff0cd4896773a87ab07cb249835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b50c8182b63eb2fdd555fe68f8234a"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a83b50c8182b63eb2fdd555fe68f8234a">fileExists</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;fileName)</td></tr>
<tr class="memdesc:a83b50c8182b63eb2fdd555fe68f8234a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given file exists.  <a href="#a83b50c8182b63eb2fdd555fe68f8234a">More...</a><br/></td></tr>
<tr class="separator:a83b50c8182b63eb2fdd555fe68f8234a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1df1bfc6b7dda41ce0605c3f84697a1"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#af1df1bfc6b7dda41ce0605c3f84697a1">dirExists</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;dirName)</td></tr>
<tr class="memdesc:af1df1bfc6b7dda41ce0605c3f84697a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given directory exists.  <a href="#af1df1bfc6b7dda41ce0605c3f84697a1">More...</a><br/></td></tr>
<tr class="separator:af1df1bfc6b7dda41ce0605c3f84697a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1359581c7afe9f05fa07cfa8d39f76"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a5a1359581c7afe9f05fa07cfa8d39f76">isReadable</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;pathName)</td></tr>
<tr class="memdesc:a5a1359581c7afe9f05fa07cfa8d39f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given path is readable.  <a href="#a5a1359581c7afe9f05fa07cfa8d39f76">More...</a><br/></td></tr>
<tr class="separator:a5a1359581c7afe9f05fa07cfa8d39f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6830a471647017f720c1f553fc7df3"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a9e6830a471647017f720c1f553fc7df3">isWriteable</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;pathName)</td></tr>
<tr class="memdesc:a9e6830a471647017f720c1f553fc7df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given path is writeable.  <a href="#a9e6830a471647017f720c1f553fc7df3">More...</a><br/></td></tr>
<tr class="separator:a9e6830a471647017f720c1f553fc7df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f1f2a618e927325493857ccde06ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#abc8f1f2a618e927325493857ccde06ea">getDirNameFromPath</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;pathName, const OFBool assumeDirName=OFTrue)</td></tr>
<tr class="memdesc:abc8f1f2a618e927325493857ccde06ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">get directory name component from given path name.  <a href="#abc8f1f2a618e927325493857ccde06ea">More...</a><br/></td></tr>
<tr class="separator:abc8f1f2a618e927325493857ccde06ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f26a515f7ece3677368b94904456bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ae8f26a515f7ece3677368b94904456bc">getFilenameFromPath</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;pathName, const OFBool assumeFilename=OFTrue)</td></tr>
<tr class="memdesc:ae8f26a515f7ece3677368b94904456bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get file name component from given path name.  <a href="#ae8f26a515f7ece3677368b94904456bc">More...</a><br/></td></tr>
<tr class="separator:ae8f26a515f7ece3677368b94904456bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8aab1b29efc9650e072f8010693c9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#acb8aab1b29efc9650e072f8010693c9a">normalizeDirName</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;dirName, const OFBool allowEmptyDirName=OFFalse)</td></tr>
<tr class="memdesc:acb8aab1b29efc9650e072f8010693c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalize the given directory name.  <a href="#acb8aab1b29efc9650e072f8010693c9a">More...</a><br/></td></tr>
<tr class="separator:acb8aab1b29efc9650e072f8010693c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf004f61fc88f37e2b70a06b39df8f32"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#adf004f61fc88f37e2b70a06b39df8f32">combineDirAndFilename</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;dirName, const <a class="el" href="classOFString.html">OFString</a> &amp;fileName, const OFBool allowEmptyDirName=OFFalse)</td></tr>
<tr class="memdesc:adf004f61fc88f37e2b70a06b39df8f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">combine the given directory and file name.  <a href="#adf004f61fc88f37e2b70a06b39df8f32">More...</a><br/></td></tr>
<tr class="separator:adf004f61fc88f37e2b70a06b39df8f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01389ac3d38be9bcbcfb112b802406fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a01389ac3d38be9bcbcfb112b802406fa">removeRootDirFromPathname</a> (<a class="el" href="classOFString.html">OFString</a> &amp;result, const <a class="el" href="classOFString.html">OFString</a> &amp;rootDir, const <a class="el" href="classOFString.html">OFString</a> &amp;pathName, const OFBool allowLeadingPathSeparator=OFTrue)</td></tr>
<tr class="memdesc:a01389ac3d38be9bcbcfb112b802406fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove root directory prefix from given path name.  <a href="#a01389ac3d38be9bcbcfb112b802406fa">More...</a><br/></td></tr>
<tr class="separator:a01389ac3d38be9bcbcfb112b802406fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7d615d55ca5d9bf0eec14b78c4b14d"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a5b7d615d55ca5d9bf0eec14b78c4b14d">searchDirectoryRecursively</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;directory, <a class="el" href="classOFList.html">OFList</a>&lt; <a class="el" href="classOFString.html">OFString</a> &gt; &amp;fileList, const <a class="el" href="classOFString.html">OFString</a> &amp;pattern, const <a class="el" href="classOFString.html">OFString</a> &amp;dirPrefix, const OFBool recurse=OFTrue)</td></tr>
<tr class="memdesc:a5b7d615d55ca5d9bf0eec14b78c4b14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">scan a given directory (recursively) and add all filenames found to a list  <a href="#a5b7d615d55ca5d9bf0eec14b78c4b14d">More...</a><br/></td></tr>
<tr class="separator:a5b7d615d55ca5d9bf0eec14b78c4b14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea18e5b201bec4e78ffe8669a2c4061d"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#aea18e5b201bec4e78ffe8669a2c4061d">deleteFile</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;filename)</td></tr>
<tr class="memdesc:aea18e5b201bec4e78ffe8669a2c4061d"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete given file from filesystem  <a href="#aea18e5b201bec4e78ffe8669a2c4061d">More...</a><br/></td></tr>
<tr class="separator:aea18e5b201bec4e78ffe8669a2c4061d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add07c3fd14037280d046a6e784968d44"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#add07c3fd14037280d046a6e784968d44">getFileSize</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;filename)</td></tr>
<tr class="memdesc:add07c3fd14037280d046a6e784968d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine size of given file (in bytes)  <a href="#add07c3fd14037280d046a6e784968d44">More...</a><br/></td></tr>
<tr class="separator:add07c3fd14037280d046a6e784968d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add32a0849552488007b4108edae7db15"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#add32a0849552488007b4108edae7db15">checkForMarkupConversion</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, const OFBool convertNonASCII=OFFalse)</td></tr>
<tr class="memdesc:add32a0849552488007b4108edae7db15"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether conversion to HTML/XML mnenonic string is required.  <a href="#add32a0849552488007b4108edae7db15">More...</a><br/></td></tr>
<tr class="separator:add32a0849552488007b4108edae7db15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e008615295da15cb19186b72dc407d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a7e008615295da15cb19186b72dc407d8">convertToMarkupStream</a> (STD_NAMESPACE ostream &amp;out, const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, const OFBool convertNonASCII=OFFalse, const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a> markupMode=<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a>, const OFBool newlineAllowed=OFFalse)</td></tr>
<tr class="memdesc:a7e008615295da15cb19186b72dc407d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert character string to HTML/XHTML/XML mnenonic stream.  <a href="#a7e008615295da15cb19186b72dc407d8">More...</a><br/></td></tr>
<tr class="separator:a7e008615295da15cb19186b72dc407d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b0617651a241ccd4be22b0b379fd99"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#af6b0617651a241ccd4be22b0b379fd99">convertToMarkupString</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;sourceString, <a class="el" href="classOFString.html">OFString</a> &amp;markupString, const OFBool convertNonASCII=OFFalse, const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a> markupMode=<a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a>, const OFBool newlineAllowed=OFFalse)</td></tr>
<tr class="memdesc:af6b0617651a241ccd4be22b0b379fd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert character string to HTML/XHTML/XML mnenonic string.  <a href="#af6b0617651a241ccd4be22b0b379fd99">More...</a><br/></td></tr>
<tr class="separator:af6b0617651a241ccd4be22b0b379fd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c73d3768e94a2a653ec0c3bf541a30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOFCondition.html">OFCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad8c73d3768e94a2a653ec0c3bf541a30">encodeBase64</a> (STD_NAMESPACE ostream &amp;out, const unsigned char *data, const size_t length, const size_t width=0)</td></tr>
<tr class="memdesc:ad8c73d3768e94a2a653ec0c3bf541a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">encode binary data according to "Base64" as described in RFC 2045 (MIME).  <a href="#ad8c73d3768e94a2a653ec0c3bf541a30">More...</a><br/></td></tr>
<tr class="separator:ad8c73d3768e94a2a653ec0c3bf541a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cd8f17965cbb801ba310f97ba5cbf0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a51cd8f17965cbb801ba310f97ba5cbf0">encodeBase64</a> (const unsigned char *data, const size_t length, <a class="el" href="classOFString.html">OFString</a> &amp;result, const size_t width=0)</td></tr>
<tr class="memdesc:a51cd8f17965cbb801ba310f97ba5cbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">encode binary data according to "Base64" as described in RFC 2045 (MIME).  <a href="#a51cd8f17965cbb801ba310f97ba5cbf0">More...</a><br/></td></tr>
<tr class="separator:a51cd8f17965cbb801ba310f97ba5cbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda935a045ecb15af0297c46911a66a"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a6dda935a045ecb15af0297c46911a66a">decodeBase64</a> (const <a class="el" href="classOFString.html">OFString</a> &amp;data, unsigned char *&amp;result)</td></tr>
<tr class="memdesc:a6dda935a045ecb15af0297c46911a66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode "Base64" encoded string.  <a href="#a6dda935a045ecb15af0297c46911a66a">More...</a><br/></td></tr>
<tr class="separator:a6dda935a045ecb15af0297c46911a66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7df9cb243dbe2dd23141c3fd2b674a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a7d7df9cb243dbe2dd23141c3fd2b674a">atof</a> (const char *s, OFBool *success=NULL)</td></tr>
<tr class="memdesc:a7d7df9cb243dbe2dd23141c3fd2b674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a floating-point number from an ASCII decimal representation to internal double-precision format.  <a href="#a7d7df9cb243dbe2dd23141c3fd2b674a">More...</a><br/></td></tr>
<tr class="separator:a7d7df9cb243dbe2dd23141c3fd2b674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b6fc5fcf8a280ef6e9d3ca2ef59071"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#ad7b6fc5fcf8a280ef6e9d3ca2ef59071">ftoa</a> (char *target, size_t targetSize, double value, unsigned int flags=0, int width=0, int precision=-1)</td></tr>
<tr class="memdesc:ad7b6fc5fcf8a280ef6e9d3ca2ef59071"><td class="mdescLeft">&#160;</td><td class="mdescRight">formats a floating-point number into an ASCII string.  <a href="#ad7b6fc5fcf8a280ef6e9d3ca2ef59071">More...</a><br/></td></tr>
<tr class="separator:ad7b6fc5fcf8a280ef6e9d3ca2ef59071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed820cdabc3f62f4eac6ca9ec0edf7d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a3ed820cdabc3f62f4eac6ca9ec0edf7d">sleep</a> (unsigned int seconds)</td></tr>
<tr class="memdesc:a3ed820cdabc3f62f4eac6ca9ec0edf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored  <a href="#a3ed820cdabc3f62f4eac6ca9ec0edf7d">More...</a><br/></td></tr>
<tr class="separator:a3ed820cdabc3f62f4eac6ca9ec0edf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584d8652b4cb42324fefdee3e52fb6f5"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a584d8652b4cb42324fefdee3e52fb6f5">getProcessID</a> ()</td></tr>
<tr class="memdesc:a584d8652b4cb42324fefdee3e52fb6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the identification of the running process.  <a href="#a584d8652b4cb42324fefdee3e52fb6f5">More...</a><br/></td></tr>
<tr class="separator:a584d8652b4cb42324fefdee3e52fb6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d80e99fa0437dc44b7ea184178da7f"><td class="memItemLeft" align="right" valign="top">static OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#af1d80e99fa0437dc44b7ea184178da7f">check32BitAddOverflow</a> (const Uint32 summand1, const Uint32 summand2)</td></tr>
<tr class="memdesc:af1d80e99fa0437dc44b7ea184178da7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the addition of two 32-bit integers yields in an overflow  <a href="#af1d80e99fa0437dc44b7ea184178da7f">More...</a><br/></td></tr>
<tr class="separator:af1d80e99fa0437dc44b7ea184178da7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">ftoa() processing flags.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags can be combined by bit-wise or. </p>
</div></td></tr>
<tr class="memitem:afbc8512bc24b94123411787c2d126b13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbc8512bc24b94123411787c2d126b13"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#afbc8512bc24b94123411787c2d126b13">ftoa_format_e</a></td></tr>
<tr class="memdesc:afbc8512bc24b94123411787c2d126b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use e or E conversion format instead of g or G. <br/></td></tr>
<tr class="separator:afbc8512bc24b94123411787c2d126b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c2e202747b725557d5705d2d0d508a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01c2e202747b725557d5705d2d0d508a"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a01c2e202747b725557d5705d2d0d508a">ftoa_format_f</a></td></tr>
<tr class="memdesc:a01c2e202747b725557d5705d2d0d508a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use f or F conversion format instead of g or G. <br/></td></tr>
<tr class="separator:a01c2e202747b725557d5705d2d0d508a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967f5c81135e0222b9edb42b5d3d5d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a967f5c81135e0222b9edb42b5d3d5d00"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a967f5c81135e0222b9edb42b5d3d5d00">ftoa_uppercase</a></td></tr>
<tr class="memdesc:a967f5c81135e0222b9edb42b5d3d5d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use E, F or G conversion format instead of e, f or g. <br/></td></tr>
<tr class="separator:a967f5c81135e0222b9edb42b5d3d5d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61132d71787b968a6cd6b31feebf444c"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a61132d71787b968a6cd6b31feebf444c">ftoa_alternate</a></td></tr>
<tr class="memdesc:a61132d71787b968a6cd6b31feebf444c"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert value to alternate form.  <a href="#a61132d71787b968a6cd6b31feebf444c">More...</a><br/></td></tr>
<tr class="separator:a61132d71787b968a6cd6b31feebf444c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4682ec4cee9093d061a3553a135927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f4682ec4cee9093d061a3553a135927"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a8f4682ec4cee9093d061a3553a135927">ftoa_leftadj</a></td></tr>
<tr class="memdesc:a8f4682ec4cee9093d061a3553a135927"><td class="mdescLeft">&#160;</td><td class="mdescRight">left-justify number be within the field <br/></td></tr>
<tr class="separator:a8f4682ec4cee9093d061a3553a135927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b0efc266c98d3b418c09ce74d11bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a691b0efc266c98d3b418c09ce74d11bc"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a691b0efc266c98d3b418c09ce74d11bc">ftoa_zeropad</a></td></tr>
<tr class="memdesc:a691b0efc266c98d3b418c09ce74d11bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">pad with zeroes instead of blanks <br/></td></tr>
<tr class="separator:a691b0efc266c98d3b418c09ce74d11bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa21c30d9a33fb433a55612c1d076e036"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#aa21c30d9a33fb433a55612c1d076e036">my_strlcpy</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:aa21c30d9a33fb433a55612c1d076e036"><td class="mdescLeft">&#160;</td><td class="mdescRight">private implementation of strlcpy.  <a href="#aa21c30d9a33fb433a55612c1d076e036">More...</a><br/></td></tr>
<tr class="separator:aa21c30d9a33fb433a55612c1d076e036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fababea6178d5b259fb75109e66f1"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a359fababea6178d5b259fb75109e66f1">my_strlcat</a> (char *dst, const char *src, size_t siz)</td></tr>
<tr class="memdesc:a359fababea6178d5b259fb75109e66f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">private implementation of strlcat.  <a href="#a359fababea6178d5b259fb75109e66f1">More...</a><br/></td></tr>
<tr class="separator:a359fababea6178d5b259fb75109e66f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1285ab82274641c1c0a510df9e216d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFStandard.html#a1b1285ab82274641c1c0a510df9e216d">my_sleep</a> (unsigned int seconds)</td></tr>
<tr class="memdesc:a1b1285ab82274641c1c0a510df9e216d"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored  <a href="#a1b1285ab82274641c1c0a510df9e216d">More...</a><br/></td></tr>
<tr class="separator:a1b1285ab82274641c1c0a510df9e216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for various helper functions. </p>
<p>This class is used to comprise a number of "global" helper functions. </p>

<p>Definition at line <a class="el" href="ofstd_8h_source.html#l00059">59</a> of file <a class="el" href="ofstd_8h_source.html">ofstd.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ada06320031143da5f04f68826f7b5b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">OFStandard::E_MarkupMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Markup language mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3faea5ae864481ee16f0a99da4fea78715d"></a>MM_HTML</em>&nbsp;</td><td class="fielddoc">
<p>HTML (Hyper Text Markup Language) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3fa47e3f34b8f31923b7d7968c0ab5cb7e7"></a>MM_HTML32</em>&nbsp;</td><td class="fielddoc">
<p>HTML 3.2 (Hyper Text Markup Language) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3fa802ef3634b97b4fad9effb1955463dcc"></a>MM_XHTML</em>&nbsp;</td><td class="fielddoc">
<p>XHTML (Extensible Hyper Text Markup Language) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d"></a>MM_XML</em>&nbsp;</td><td class="fielddoc">
<p>XML (Extensible Markup Language) </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="ofstd_8h_source.html#l00068">68</a> of file <a class="el" href="ofstd_8h_source.html">ofstd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7d7df9cb243dbe2dd23141c3fd2b674a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OFStandard::atof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OFBool *&#160;</td>
          <td class="paramname"><em>success</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts a floating-point number from an ASCII decimal representation to internal double-precision format. </p>
<p>Unlike the <a class="el" href="classOFStandard.html#a7d7df9cb243dbe2dd23141c3fd2b674a" title="converts a floating-point number from an ASCII decimal representation to internal double-precision fo...">atof()</a> function defined in Posix, this implementation is not affected by a locale setting, the radix character is always assumed to be '.' This implementation does not set errno if the input cannot be parsed and it does not implement special handling for overflow/underflow or NaN values. However, a return code indicates whether or not a successful conversion could be performed. The precision of this implementation is limited to approx. 9 decimal digits. The use of this implementation can be disabled by defining the macro DISABLE_OFSTD_ATOF at compile time; in this case, the locale dependent Posix implementation of sscanf is used and the application is responsible for making sure that the Posix locale is activated at all times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A decimal ASCII floating-point number, optionally preceded by white space. Must have form "-I.FE-X", where I is the integer part of the mantissa, F is the fractional part of the mantissa, and X is the exponent. Either of the signs may be "+", "-", or omitted. Either I or F may be omitted, or both. The decimal point isn't necessary unless F is present. The "E" may actually be an "e". E and X may both be omitted (but not just one). </td></tr>
    <tr><td class="paramname">success</td><td>pointer to return status code, may be NULL. if present, a status code is stored in the variable pointed to by this parameter. The status is OFTrue if a conversion could be performed and OFFalse if the string does not have the expected format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>floating-point equivalent of string. If a terminating character is found before any floating-point digits, then zero is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="af1d80e99fa0437dc44b7ea184178da7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::check32BitAddOverflow </td>
          <td>(</td>
          <td class="paramtype">const Uint32&#160;</td>
          <td class="paramname"><em>summand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32&#160;</td>
          <td class="paramname"><em>summand2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the addition of two 32-bit integers yields in an overflow </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">summand1</td><td>first integer value to be added </td></tr>
    <tr><td class="paramname">summand2</td><td>second integer value to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if an overflow occurred during the addition, OFFalse otherwise </dd></dl>

<p>Definition at line <a class="el" href="ofstd_8h_source.html#l00564">564</a> of file <a class="el" href="ofstd_8h_source.html">ofstd.h</a>.</p>

</div>
</div>
<a class="anchor" id="add32a0849552488007b4108edae7db15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::checkForMarkupConversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>convertNonASCII</em> = <code>OFFalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether conversion to HTML/XML mnenonic string is required. </p>
<p>This check can be performed before <a class="el" href="classOFStandard.html#a7e008615295da15cb19186b72dc407d8" title="convert character string to HTML/XHTML/XML mnenonic stream.">convertToMarkupStream()</a> or <a class="el" href="classOFStandard.html#af6b0617651a241ccd4be22b0b379fd99" title="convert character string to HTML/XHTML/XML mnenonic string.">convertToMarkupString()</a> is called in order to speed up the process in case the conversion is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceString</td><td>source string to be checked </td></tr>
    <tr><td class="paramname">convertNonASCII</td><td>convert non-ASCII characters (&lt; #32 and &gt;= #127) to numeric value (&amp;#nnn;) if OFTrue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if markup conversion is required, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adf004f61fc88f37e2b70a06b39df8f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::combineDirAndFilename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>allowEmptyDirName</em> = <code>OFFalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>combine the given directory and file name. </p>
<p>Normalizes the directory name and appends the file name (with a path separator) if not empty. If both 'dirName' and 'fileName' are empty strings and the flag 'allowEmptyDirName' is OFFalse the resulting path name is set to "." (current directory). If 'dirName' is "." and the flag 'allowEmptyDirName' is OFTrue an empty directory name is used. NB: This function neither checks whether the given 'dirName' exists nor whether the resulting path name points to a valid or existing file name. Furthermore, the value of 'dirName' is ignored if 'fileName' starts with a path separator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting path name is stored </td></tr>
    <tr><td class="paramname">dirName</td><td>directory name to be combined with the file name </td></tr>
    <tr><td class="paramname">fileName</td><td>file name to be combined with the directory name </td></tr>
    <tr><td class="paramname">allowEmptyDirName</td><td>flag indicating whether an empty directory name is allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting path name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="a7e008615295da15cb19186b72dc407d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::convertToMarkupStream </td>
          <td>(</td>
          <td class="paramtype">STD_NAMESPACE ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>convertNonASCII</em> = <code>OFFalse</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a>&#160;</td>
          <td class="paramname"><em>markupMode</em> = <code><a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>newlineAllowed</em> = <code>OFFalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert character string to HTML/XHTML/XML mnenonic stream. </p>
<p>Characters with special meaning for HTML/XHTML/XML (e.g. '&lt;' and '&amp;') are replaced by the corresponding mnenonics (e.g. "&amp;lt;" and "&amp;amp;"). If flag 'convertNonASCII' is OFTrue, all characters &lt; #32 and &gt;= #127 are also converted (useful if only HTML 3.2 is supported which does not allow to specify the character set). In HTML 3.2 mode, the quotation mark (") is converted to "&amp;#34;" instead of """ because the latter entity is not defined.
In HTML mode, the apostrophe sign (') is converted to "&amp;#39;" instead of "'" for the same reason. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>stream used for the HTML/XHTML/XML mnenonic output </td></tr>
    <tr><td class="paramname">sourceString</td><td>source string to be converted </td></tr>
    <tr><td class="paramname">convertNonASCII</td><td>convert non-ASCII characters (&lt; # 32 and &gt;= #127) to numeric value (&amp;#nnn;) if OFTrue </td></tr>
    <tr><td class="paramname">markupMode</td><td>convert to HTML, HTML 3.2, XHTML or XML markup. LF and CR are encoded as "&amp;#10;" and "&amp;#13;" in XML mode, the flag 'newlineAllowed' has no meaning in this case. </td></tr>
    <tr><td class="paramname">newlineAllowed</td><td>optional flag indicating whether newlines are allowed or not. If they are allowed the text "&lt;br&gt;" (HTML) or "&lt;br /&gt;" (XHTML) is used, "&amp;para;" otherwise. The following combinations are accepted: LF, CR, LF CR, CF LF. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, always returns EC_Normal </dd></dl>

</div>
</div>
<a class="anchor" id="af6b0617651a241ccd4be22b0b379fd99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::convertToMarkupString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>markupString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>convertNonASCII</em> = <code>OFFalse</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3f">E_MarkupMode</a>&#160;</td>
          <td class="paramname"><em>markupMode</em> = <code><a class="el" href="classOFStandard.html#ada06320031143da5f04f68826f7b5b3faf9de720cac130a448fba3a1bdee3592d">MM_XML</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>newlineAllowed</em> = <code>OFFalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert character string to HTML/XHTML/XML mnenonic string. </p>
<p>Characters with special meaning for HTML/XHTML/XML (e.g. '&lt;' and '&amp;') are replaced by the corresponding mnenonics (e.g. "&amp;lt;" and "&amp;amp;"). If flag 'convertNonASCII' is OFTrue, all characters &lt; #32 and &gt;= #127 are also converted (useful if only HTML 3.2 is supported which does not allow to specify the character set). In HTML 3.2 mode, the quotation mark (") is converted to "&amp;#34;" instead of """ because the latter entity is not defined.
In HTML mode, the apostrophe sign (') is converted to "&amp;#39;" instead of "'" for the same reason. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceString</td><td>source string to be converted </td></tr>
    <tr><td class="paramname">markupString</td><td>reference to character string where the result should be stored </td></tr>
    <tr><td class="paramname">convertNonASCII</td><td>convert non-ASCII characters (&lt; # 32 and &gt;= #127) to numeric value (&amp;#nnn;) if OFTrue </td></tr>
    <tr><td class="paramname">markupMode</td><td>convert to HTML, HTML 3.2, XHTML or XML markup string. LF and CR are encoded as "@&amp;@#10;" and "@&amp;@#13;" in XML mode, the flag 'newlineAllowed' has no meaning in this case. </td></tr>
    <tr><td class="paramname">newlineAllowed</td><td>optional flag indicating whether newlines are allowed or not. If they are allowed the text "&lt;br&gt;" (HTML) or "&lt;br /&gt;" (XHTML) is used, "&amp;para;" otherwise. The following combinations are accepted: LF, CR, LF CR, CF LF. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to resulting 'markupString' (might be empty if 'sourceString' was empty) </dd></dl>

</div>
</div>
<a class="anchor" id="a6dda935a045ecb15af0297c46911a66a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::decodeBase64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decode "Base64" encoded string. </p>
<p>Any character that does not belong to the Base64 alphabet (0..9, A..Z, a..z, + and /) is ignored when decoding the input string. This is especially true for line breaks which are usually contained in MIME (RFC 2045) encoded streams (see above). The first occurence of a '=' character is taken as evidence that the end of the data has been reached. NB: The memory buffer in which the binary output is stored is allocated inside this function and has to to be freed (using "delete[]") by the caller! Do not pass a pointer to an already allocated buffer to this function, the caller does not know the exact size anyway. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Base64 encoded input data (possibly padded with '=' at the end) </td></tr>
    <tr><td class="paramname">result</td><td>receives pointer to resulting buffer with binary data (big endian encoded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the resulting binary data (0 if an error occurred, in this case the buffer is deleted internally) </dd></dl>

</div>
</div>
<a class="anchor" id="aea18e5b201bec4e78ffe8669a2c4061d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::deleteFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete given file from filesystem </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file (including directory) to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if deletion was successul, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af1df1bfc6b7dda41ce0605c3f84697a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::dirExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given directory exists. </p>
<p>This function also checks that the specified path points to directory and not to a file (or the like). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirName</td><td>name of the directory to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if directory exists, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c73d3768e94a2a653ec0c3bf541a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::encodeBase64 </td>
          <td>(</td>
          <td class="paramtype">STD_NAMESPACE ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encode binary data according to "Base64" as described in RFC 2045 (MIME). </p>
<p>Basic algorithm: groups of 3 bytes from the binary input are coded as groups of 4 bytes in the textual output. The input data is 'padded' with zeros to create a length that is an even multiple of 3. A special character ('=') is used to denote padding so that the output can be decoded back to its exact size. If the input data is NULL an error code (EC_IllegalParameter) is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream used for the base64 encoded data </td></tr>
    <tr><td class="paramname">data</td><td>buffer with binary data to be encoded (big endian required!) </td></tr>
    <tr><td class="paramname">length</td><td>length of the input data buffer (in bytes) </td></tr>
    <tr><td class="paramname">width</td><td>maximum number of characters per line in the output stream (default: 0 = no line breaks, typical for MIME = 72) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, EC_Normal if successful, an error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a51cd8f17965cbb801ba310f97ba5cbf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::encodeBase64 </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>encode binary data according to "Base64" as described in RFC 2045 (MIME). </p>
<p>Basic algorithm: groups of 3 bytes from the binary input are coded as groups of 4 bytes in the textual output. The input data is 'padded' with zeros to create a length that is an even multiple of 3. A special character ('=') is used to denote padding so that the output can be decoded back to its exact size. If the input data is NULL an empty string is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>buffer with binary data to be encoded (big endian required!) </td></tr>
    <tr><td class="paramname">length</td><td>length of the input data buffer (in bytes) </td></tr>
    <tr><td class="paramname">result</td><td>reference to resulting string variable (Base64 encoded) </td></tr>
    <tr><td class="paramname">width</td><td>maximum number of characters per line in the output string (default: 0 = no line breaks, typical for MIME = 72) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string </dd></dl>

</div>
</div>
<a class="anchor" id="a83b50c8182b63eb2fdd555fe68f8234a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::fileExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given file exists. </p>
<p>This function also checks that the specified path points to file and not to a directory (or the like). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>name of the file to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if file exists, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad7b6fc5fcf8a280ef6e9d3ca2ef59071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OFStandard::ftoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>formats a floating-point number into an ASCII string. </p>
<p>This function works similar to sprintf(), except that this implementation is not affected by a locale setting. The radix character is always '.'.</p>
<p>This implementation guarantees that the given string size is always respected by using strlcpy to copy the formatted string into the target buffer.</p>
<p>The use of this implementation can be disabled by defining the macro DISABLE_OFSTD_FTOA at compile time; in this case, the locale dependent Posix implementation of sprintf is used and the application is responsible for making sure that the Posix locale is activated at all times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>pointer to target string buffer </td></tr>
    <tr><td class="paramname">targetSize</td><td>size of target string buffer </td></tr>
    <tr><td class="paramname">value</td><td>double value to be formatted </td></tr>
    <tr><td class="paramname">flags</td><td>processing flags. Any of the flags defined below can be combined by bit-wise or. </td></tr>
    <tr><td class="paramname">width</td><td>width from format (%8d), or 0 </td></tr>
    <tr><td class="paramname">precision</td><td>precision from format (%.3d), or -1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc8f1f2a618e927325493857ccde06ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::getDirNameFromPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>assumeDirName</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get directory name component from given path name. </p>
<p>Extracts the substring before the last path separator. If there is no path separator in the given path name, the value of 'pathName' is returned by default; if 'assumeDirName' is OFFalse, an empty string is returned. NB: This function neither checks whether the given 'pathName' exists nor whether the resulting name points to a valid or existing directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting directory name is stored </td></tr>
    <tr><td class="paramname">pathName</td><td>path name from which the directory name should be extracted </td></tr>
    <tr><td class="paramname">assumeDirName</td><td>assume that there always is a directory name in 'pathName' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting directory name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="ae8f26a515f7ece3677368b94904456bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::getFilenameFromPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>assumeFilename</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get file name component from given path name. </p>
<p>Extracts the substring after the last path separator. If there is no path separator in the given path name, the value of 'pathName' is returned by default; if 'assumeFilename' is OFFalse, an empty string is returned. NB: This function neither checks whether the given 'pathName' exists nor whether the resulting name points to a valid or existing file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting file name is stored </td></tr>
    <tr><td class="paramname">pathName</td><td>path name from which the file name should be extracted </td></tr>
    <tr><td class="paramname">assumeFilename</td><td>assume that there always is a file name in 'pathName' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting file name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="add07c3fd14037280d046a6e784968d44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::getFileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine size of given file (in bytes) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the file in bytes (0 in case of error) </dd></dl>

</div>
</div>
<a class="anchor" id="a584d8652b4cb42324fefdee3e52fb6f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long OFStandard::getProcessID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the identification of the running process. </p>
<dl class="section return"><dt>Returns</dt><dd>the process ID of the currently running process. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a1359581c7afe9f05fa07cfa8d39f76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::isReadable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given path is readable. </p>
<p>This function works for both files and directories. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathName</td><td>name of the path to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if path is readable, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6830a471647017f720c1f553fc7df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::isWriteable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given path is writeable. </p>
<p>This function works for both files and directories. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathName</td><td>name of the path to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if path is writeable, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1b1285ab82274641c1c0a510df9e216d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int OFStandard::my_sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of seconds to sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the requested time has elapsed, or the number of seconds left to sleep </dd></dl>

<p>Referenced by <a class="el" href="ofstd_8h_source.html#l00543">sleep()</a>.</p>

</div>
</div>
<a class="anchor" id="a359fababea6178d5b259fb75109e66f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::my_strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private implementation of strlcat. </p>
<p>Called when strlcat is not available in the standard library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. the initial length of dst plus the length of src </dd></dl>

<p>Referenced by <a class="el" href="ofstd_8h_source.html#l00123">strlcat()</a>.</p>

</div>
</div>
<a class="anchor" id="aa21c30d9a33fb433a55612c1d076e036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::my_strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private implementation of strlcpy. </p>
<p>Called when strlcpy is not available in the standard library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. strlen(src) </dd></dl>

<p>Referenced by <a class="el" href="ofstd_8h_source.html#l00097">strlcpy()</a>.</p>

</div>
</div>
<a class="anchor" id="acb8aab1b29efc9650e072f8010693c9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::normalizeDirName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>allowEmptyDirName</em> = <code>OFFalse</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalize the given directory name. </p>
<p>Removes trailing path separators from the directory name. If the resulting directory name is an empty string and the flag 'allowEmptyDirName' is OFFalse the directory name is set to "." (current directory). If the resulting directory name is "." and the flag 'allowEmptyDirName' is OFTrue the directory name is set to an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting directory name is stored </td></tr>
    <tr><td class="paramname">dirName</td><td>directory name to be normalized </td></tr>
    <tr><td class="paramname">allowEmptyDirName</td><td>flag indicating whether an empty directory name is allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting directory name (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="a8b3d7ff0cd4896773a87ab07cb249835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OFBool OFStandard::pathExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the given path exists. </p>
<p>This function does not distinguish files from directories (use '<a class="el" href="classOFStandard.html#a83b50c8182b63eb2fdd555fe68f8234a" title="check whether the given file exists.">fileExists()</a>' or 'directoryExists()' if required). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathName</td><td>name of the path to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OFTrue if path exists, OFFalse otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a01389ac3d38be9bcbcfb112b802406fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFCondition.html">OFCondition</a> OFStandard::removeRootDirFromPathname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>rootDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pathName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>allowLeadingPathSeparator</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove root directory prefix from given path name. </p>
<p>In case 'pathName' starts with 'rootDir', the common prefix is removed. Otherwise, an empty string is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the resulting path name is stored </td></tr>
    <tr><td class="paramname">rootDir</td><td>name of the root directory to be removed </td></tr>
    <tr><td class="paramname">pathName</td><td>path name from which the root directory (prefix) is removed </td></tr>
    <tr><td class="paramname">allowLeadingPathSeparator</td><td>flag indicating whether a leading path separator is allowed for the resulting path name (automatically removed otherwise) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status, EC_Normal if successful, an error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a5b7d615d55ca5d9bf0eec14b78c4b14d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::searchDirectoryRecursively </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFList.html">OFList</a>&lt; <a class="el" href="classOFString.html">OFString</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>dirPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OFBool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>OFTrue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scan a given directory (recursively) and add all filenames found to a list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>name of the directory to be scanned </td></tr>
    <tr><td class="paramname">fileList</td><td>list to which the filenames are added. Please note that the list is not not cleared automatically. </td></tr>
    <tr><td class="paramname">pattern</td><td>optional wildcard pattern used to match the filenames against. By default all files match. In order to work under Unix the system function fnmatch() is required. </td></tr>
    <tr><td class="paramname">dirPrefix</td><td>optional prefix added to the directory name. This prefix will, however, not be part of the filenames added to the list. </td></tr>
    <tr><td class="paramname">recurse</td><td>flag indicating whether to search recursively (default) or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of new files added to the list </dd></dl>

</div>
</div>
<a class="anchor" id="a3ed820cdabc3f62f4eac6ca9ec0edf7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int OFStandard::sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes the current process sleep until seconds seconds have elapsed or a signal arrives which is not ignored </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of seconds to sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the requested time has elapsed, or the number of seconds left to sleep </dd></dl>

<p>Definition at line <a class="el" href="ofstd_8h_source.html#l00543">543</a> of file <a class="el" href="ofstd_8h_source.html">ofstd.h</a>.</p>

<p>References <a class="el" href="classOFStandard.html#a1b1285ab82274641c1c0a510df9e216d">my_sleep()</a>.</p>

</div>
</div>
<a class="anchor" id="ad29b92d97c56b8f42dcdf011abfcf201"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* OFStandard::strerror </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>errnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a given error code to a string. </p>
<p>This function wraps the various approaches found on different systems. Internally, the standard function <a class="el" href="classOFStandard.html#ad29b92d97c56b8f42dcdf011abfcf201" title="convert a given error code to a string.">strerror()</a> or strerror_r() is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>error code to be converted </td></tr>
    <tr><td class="paramname">buf</td><td>buffer which is used to store the result string (if supported) </td></tr>
    <tr><td class="paramname">buflen</td><td>size if the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to string describing the error code. Please note that depending on the implementation of the function used, the result may or may not be a pointer to buf. The return value can also be NULL if the buffer is invalid. </dd></dl>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00707">OFFile::getLastErrorString()</a>.</p>

</div>
</div>
<a class="anchor" id="a976613403ca9423d19867b22e92fd663"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function appends the NUL-terminated string src to the end of dst. </p>
<p>It will append at most size - strlen(dst) - 1 bytes, NUL- terminating the result. It is designed to be a safer, more consistent, and less error-prone replacement for strncat(3). strlcat takes the full size of the buffer (not just the length) and guarantees to NUL-terminate the result (as long as size is larger than 0). Note that you should include a byte for the NUL in size. Also note that strlcat only operates on true C strings, i. e. dst and src must be NUL-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. the initial length of dst plus the length of src. While this may seem somewhat confusing it was done to make truncation detection simple. </dd></dl>

<p>Definition at line <a class="el" href="ofstd_8h_source.html#l00123">123</a> of file <a class="el" href="ofstd_8h_source.html">ofstd.h</a>.</p>

<p>References <a class="el" href="classOFStandard.html#a359fababea6178d5b259fb75109e66f1">my_strlcat()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3aaaedae7176ef90b36af8cdf7ee648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t OFStandard::strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function copies up to size - 1 characters from the NUL- terminated string src to dst, NUL-terminating the result. </p>
<p>It is designed to be a safer, more consistent, and less error-prone replacement for strncpy(3). strlcpy takes the full size of the buffer (not just the length) and guarantees to NUL-terminate the result (as long as size is larger than 0). Note that you should include a byte for the NUL in size. Also note that strlcpy only operates on true C strings, i. e. src must be NUL-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer of size siz, must not be NULL </td></tr>
    <tr><td class="paramname">src</td><td>source string, must not be NULL </td></tr>
    <tr><td class="paramname">siz</td><td>size of destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the string the function tried to create, i.e. strlen(src). While this may seem somewhat confusing it was done to make truncation detection simple. </dd></dl>

<p>Definition at line <a class="el" href="ofstd_8h_source.html#l00097">97</a> of file <a class="el" href="ofstd_8h_source.html">ofstd.h</a>.</p>

<p>References <a class="el" href="classOFStandard.html#aa21c30d9a33fb433a55612c1d076e036">my_strlcpy()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a21841dc6a358c17415b8422e0084d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the lower-case version of a given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the result is stored </td></tr>
    <tr><td class="paramname">value</td><td>string value to be converted to lower case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="ade3b699ce3361e253f973c6203a92781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the lower-case version of a given string. </p>
<p>NB: This function changes the parameter 'value'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>string value to be converted to lower case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'value') </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7a81568899f73c7292f155096d5ef1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toUpper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the upper-case version of a given string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>string variable in which the result is stored </td></tr>
    <tr><td class="paramname">value</td><td>string value to be converted to upper case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'result') </dd></dl>

</div>
</div>
<a class="anchor" id="ad83a26201452fd4a102edf3f4a719fdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOFString.html">OFString</a>&amp; OFStandard::toUpper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the upper-case version of a given string. </p>
<p>NB: This function changes the parameter 'value'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>string value to be converted to upper case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the resulting string (same as 'value') </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a61132d71787b968a6cd6b31feebf444c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int OFStandard::ftoa_alternate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert value to alternate form. </p>
<p>The result will always contain a decimal point, even if no digits follow the point. For g and G conversions, trailing zeroes will not be removed from the result. </p>

<p>Definition at line <a class="el" href="ofstd_8h_source.html#l00528">528</a> of file <a class="el" href="ofstd_8h_source.html">ofstd.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>F:/Projects/GigaVoxels/Livraison_GV/ThirdDependencies/windows-VS2013-x64/dcmtk-3.6.0_VS2013/ofstd/include/dcmtk/ofstd/<a class="el" href="ofstd_8h_source.html">ofstd.h</a></li>
</ul>
</div><!-- contents -->
<p>
<hr>
<small>
Generated on Thu Jul 23 2015 for <a href="http://dicom.offis.de/dcmtk">OFFIS DCMTK</a> Version 3.6.0 by <a href="http://www.doxygen.org/">Doxygen</a> 1.8.3.1
</small>
