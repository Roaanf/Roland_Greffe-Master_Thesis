<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OFFIS DCMTK: OFFile Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OFFIS DCMTK
   &#160;<span id="projectnumber">Version 3.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classOFFile-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OFFile Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>this class provides a simple C++ encapsulation layer for stdio FILE pointers.  
 <a href="classOFFile.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e6544a4ee422e88bbd6629e4547e784"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e6544a4ee422e88bbd6629e4547e784"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a6e6544a4ee422e88bbd6629e4547e784">OFFile</a> ()</td></tr>
<tr class="memdesc:a6e6544a4ee422e88bbd6629e4547e784"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor, creates an object that is not associated with any file. <br/></td></tr>
<tr class="separator:a6e6544a4ee422e88bbd6629e4547e784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90c8f5310d7bc9a1c1a4f1e53853cb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#aa90c8f5310d7bc9a1c1a4f1e53853cb5">OFFile</a> (FILE *f)</td></tr>
<tr class="memdesc:aa90c8f5310d7bc9a1c1a4f1e53853cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create object for given stdio FILE  <a href="#aa90c8f5310d7bc9a1c1a4f1e53853cb5">More...</a><br/></td></tr>
<tr class="separator:aa90c8f5310d7bc9a1c1a4f1e53853cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07311f8332339a4ae8fb7bdb19cba513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07311f8332339a4ae8fb7bdb19cba513"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a07311f8332339a4ae8fb7bdb19cba513">~OFFile</a> ()</td></tr>
<tr class="memdesc:a07311f8332339a4ae8fb7bdb19cba513"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor. Closes file if still open. <br/></td></tr>
<tr class="separator:a07311f8332339a4ae8fb7bdb19cba513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36564e09a6be8503428df807cbef97cd"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a36564e09a6be8503428df807cbef97cd">fopen</a> (const char *filename, const char *modes)</td></tr>
<tr class="memdesc:a36564e09a6be8503428df807cbef97cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">opens the file whose name is the string pointed to by path and associates a stream with it.  <a href="#a36564e09a6be8503428df807cbef97cd">More...</a><br/></td></tr>
<tr class="separator:a36564e09a6be8503428df807cbef97cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96a6fddc1d4ba536d68dbf135f3cc84"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#aa96a6fddc1d4ba536d68dbf135f3cc84">fdopen</a> (int fd, const char *modes)</td></tr>
<tr class="memdesc:aa96a6fddc1d4ba536d68dbf135f3cc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">associates a stream with the existing file descriptor, fildes.  <a href="#aa96a6fddc1d4ba536d68dbf135f3cc84">More...</a><br/></td></tr>
<tr class="separator:aa96a6fddc1d4ba536d68dbf135f3cc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b221e6880cca98401576e7471b608"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a4a8b221e6880cca98401576e7471b608">popen</a> (const char *command, const char *modes)</td></tr>
<tr class="memdesc:a4a8b221e6880cca98401576e7471b608"><td class="mdescLeft">&#160;</td><td class="mdescRight">opens a process by creating a pipe, forking, and invoking the shell.  <a href="#a4a8b221e6880cca98401576e7471b608">More...</a><br/></td></tr>
<tr class="separator:a4a8b221e6880cca98401576e7471b608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215079f052d70a05f2de33277d949374"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a215079f052d70a05f2de33277d949374">freopen</a> (const char *filename, const char *modes)</td></tr>
<tr class="memdesc:a215079f052d70a05f2de33277d949374"><td class="mdescLeft">&#160;</td><td class="mdescRight">opens the file whose name is the string pointed to by path and associates the stream pointed maintained by this object with it.  <a href="#a215079f052d70a05f2de33277d949374">More...</a><br/></td></tr>
<tr class="separator:a215079f052d70a05f2de33277d949374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907499068d112855bd00ec98f52df09e"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a907499068d112855bd00ec98f52df09e">tmpfile</a> ()</td></tr>
<tr class="memdesc:a907499068d112855bd00ec98f52df09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates a unique temporary filename.  <a href="#a907499068d112855bd00ec98f52df09e">More...</a><br/></td></tr>
<tr class="separator:a907499068d112855bd00ec98f52df09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79262a03b727f2d513439901aa1a42b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#ae79262a03b727f2d513439901aa1a42b">fclose</a> ()</td></tr>
<tr class="memdesc:ae79262a03b727f2d513439901aa1a42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">dissociates the named stream from its underlying file or set of functions.  <a href="#ae79262a03b727f2d513439901aa1a42b">More...</a><br/></td></tr>
<tr class="separator:ae79262a03b727f2d513439901aa1a42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980a9c66c2342829281dc2ecebd3746"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#ac980a9c66c2342829281dc2ecebd3746">pclose</a> ()</td></tr>
<tr class="memdesc:ac980a9c66c2342829281dc2ecebd3746"><td class="mdescLeft">&#160;</td><td class="mdescRight">waits for the associated process (created with popen) to terminate and returns the exit status of the command as returned by wait4.  <a href="#ac980a9c66c2342829281dc2ecebd3746">More...</a><br/></td></tr>
<tr class="separator:ac980a9c66c2342829281dc2ecebd3746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb22aa9a65956d6d1ddf560bfb1c3305"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#adb22aa9a65956d6d1ddf560bfb1c3305">fwrite</a> (const void *ptr, size_t size, size_t n)</td></tr>
<tr class="memdesc:adb22aa9a65956d6d1ddf560bfb1c3305"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes n elements of data, each size bytes long, to the stream, obtaining them from the location given by ptr.  <a href="#adb22aa9a65956d6d1ddf560bfb1c3305">More...</a><br/></td></tr>
<tr class="separator:adb22aa9a65956d6d1ddf560bfb1c3305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117df6d307708c831f533a2e512544c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a117df6d307708c831f533a2e512544c8">fread</a> (void *ptr, size_t size, size_t n)</td></tr>
<tr class="memdesc:a117df6d307708c831f533a2e512544c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads n elements of data, each size bytes long, from the stream, storing them at the location given by ptr.  <a href="#a117df6d307708c831f533a2e512544c8">More...</a><br/></td></tr>
<tr class="separator:a117df6d307708c831f533a2e512544c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02952ff58fe0edb489364f2a855547a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a02952ff58fe0edb489364f2a855547a7">fflush</a> ()</td></tr>
<tr class="memdesc:a02952ff58fe0edb489364f2a855547a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">forces a write of all user-space buffered data for the given output or update stream via the stream's underlying write function.  <a href="#a02952ff58fe0edb489364f2a855547a7">More...</a><br/></td></tr>
<tr class="separator:a02952ff58fe0edb489364f2a855547a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39adaf2ef5813046ea35d6ae6cb26720"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a39adaf2ef5813046ea35d6ae6cb26720">fgetc</a> ()</td></tr>
<tr class="memdesc:a39adaf2ef5813046ea35d6ae6cb26720"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.  <a href="#a39adaf2ef5813046ea35d6ae6cb26720">More...</a><br/></td></tr>
<tr class="separator:a39adaf2ef5813046ea35d6ae6cb26720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaed3df732322469e7cff3076c7437d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a5aaed3df732322469e7cff3076c7437d">setlinebuf</a> ()</td></tr>
<tr class="memdesc:a5aaed3df732322469e7cff3076c7437d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three types of buffering available are unbuffered, block buffered, and line buffered.  <a href="#a5aaed3df732322469e7cff3076c7437d">More...</a><br/></td></tr>
<tr class="separator:a5aaed3df732322469e7cff3076c7437d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457f04cf811c27fd3377889c7cbf80b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a457f04cf811c27fd3377889c7cbf80b7">rewind</a> ()</td></tr>
<tr class="memdesc:a457f04cf811c27fd3377889c7cbf80b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the file position indicator for the stream pointed to by stream to the beginning of the file.  <a href="#a457f04cf811c27fd3377889c7cbf80b7">More...</a><br/></td></tr>
<tr class="separator:a457f04cf811c27fd3377889c7cbf80b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca12f72df2c2a0049d6ea9d3c1e9b16e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca12f72df2c2a0049d6ea9d3c1e9b16e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#aca12f72df2c2a0049d6ea9d3c1e9b16e">clearerr</a> ()</td></tr>
<tr class="memdesc:aca12f72df2c2a0049d6ea9d3c1e9b16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the end-of-file and error indicators for the stream <br/></td></tr>
<tr class="separator:aca12f72df2c2a0049d6ea9d3c1e9b16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da58c5e146ce906c5f3f429625d0275"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a1da58c5e146ce906c5f3f429625d0275">eof</a> () const </td></tr>
<tr class="memdesc:a1da58c5e146ce906c5f3f429625d0275"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests the end-of-file indicator for the stream, returning non-zero if it is set.  <a href="#a1da58c5e146ce906c5f3f429625d0275">More...</a><br/></td></tr>
<tr class="separator:a1da58c5e146ce906c5f3f429625d0275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2b6c3af9a8a532575e5f032f3312f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a08e2b6c3af9a8a532575e5f032f3312f">error</a> ()</td></tr>
<tr class="memdesc:a08e2b6c3af9a8a532575e5f032f3312f"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests the error indicator for the stream, returning non-zero if it is set.  <a href="#a08e2b6c3af9a8a532575e5f032f3312f">More...</a><br/></td></tr>
<tr class="separator:a08e2b6c3af9a8a532575e5f032f3312f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40babba8564844702f59c68319ffa70d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a40babba8564844702f59c68319ffa70d">fileNo</a> ()</td></tr>
<tr class="memdesc:a40babba8564844702f59c68319ffa70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the low-level file descriptor associated with the stream.  <a href="#a40babba8564844702f59c68319ffa70d">More...</a><br/></td></tr>
<tr class="separator:a40babba8564844702f59c68319ffa70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6ef2f0399a1a579826425c6a8f11c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#aeb6ef2f0399a1a579826425c6a8f11c2">setbuf</a> (char *buf)</td></tr>
<tr class="memdesc:aeb6ef2f0399a1a579826425c6a8f11c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three types of buffering available are unbuffered, block buffered, and line buffered.  <a href="#aeb6ef2f0399a1a579826425c6a8f11c2">More...</a><br/></td></tr>
<tr class="separator:aeb6ef2f0399a1a579826425c6a8f11c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90ebe1b031b5e3b442096665c9634b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#aa90ebe1b031b5e3b442096665c9634b5">setvbuf</a> (char *buf, int modes, size_t n)</td></tr>
<tr class="memdesc:aa90ebe1b031b5e3b442096665c9634b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three types of buffering available are unbuffered, block buffered, and line buffered.  <a href="#aa90ebe1b031b5e3b442096665c9634b5">More...</a><br/></td></tr>
<tr class="separator:aa90ebe1b031b5e3b442096665c9634b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023488d2b4d6aced48c10700837377cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a023488d2b4d6aced48c10700837377cb">setbuffer</a> (char *buf, size_t size)</td></tr>
<tr class="memdesc:a023488d2b4d6aced48c10700837377cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three types of buffering available are unbuffered, block buffered, and line buffered.  <a href="#a023488d2b4d6aced48c10700837377cb">More...</a><br/></td></tr>
<tr class="separator:a023488d2b4d6aced48c10700837377cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6002d5e252256817bc0135a2dc2d785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#aa6002d5e252256817bc0135a2dc2d785">fputc</a> (int c)</td></tr>
<tr class="memdesc:aa6002d5e252256817bc0135a2dc2d785"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes the character c, cast to an unsigned char, to stream.  <a href="#aa6002d5e252256817bc0135a2dc2d785">More...</a><br/></td></tr>
<tr class="separator:aa6002d5e252256817bc0135a2dc2d785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc2da7e2d642fdcdee55296d1fd617"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a25cc2da7e2d642fdcdee55296d1fd617">fgets</a> (char *s, int n)</td></tr>
<tr class="memdesc:a25cc2da7e2d642fdcdee55296d1fd617"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads in at most one less than n characters from stream and stores them into the buffer pointed to by s.  <a href="#a25cc2da7e2d642fdcdee55296d1fd617">More...</a><br/></td></tr>
<tr class="separator:a25cc2da7e2d642fdcdee55296d1fd617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9731ef2d8d2cd55c5bbbea0eabe0f490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a9731ef2d8d2cd55c5bbbea0eabe0f490">fputs</a> (const char *s)</td></tr>
<tr class="memdesc:a9731ef2d8d2cd55c5bbbea0eabe0f490"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes the string s to stream, without its trailing '\0'.  <a href="#a9731ef2d8d2cd55c5bbbea0eabe0f490">More...</a><br/></td></tr>
<tr class="separator:a9731ef2d8d2cd55c5bbbea0eabe0f490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7201dcb91429151a508bd1ebc38127d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a7201dcb91429151a508bd1ebc38127d2">ungetc</a> (int c)</td></tr>
<tr class="memdesc:a7201dcb91429151a508bd1ebc38127d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">pushes c back to stream, cast to unsigned char, where it is available for subsequent read operations.  <a href="#a7201dcb91429151a508bd1ebc38127d2">More...</a><br/></td></tr>
<tr class="separator:a7201dcb91429151a508bd1ebc38127d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8490f9cb1a5e7bcb6a48e12fa47b223d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a8490f9cb1a5e7bcb6a48e12fa47b223d">fseek</a> (offile_off_t off, int whence)</td></tr>
<tr class="memdesc:a8490f9cb1a5e7bcb6a48e12fa47b223d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the file position indicator for the stream pointed to by stream.  <a href="#a8490f9cb1a5e7bcb6a48e12fa47b223d">More...</a><br/></td></tr>
<tr class="separator:a8490f9cb1a5e7bcb6a48e12fa47b223d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815432fffe399103ac661e57a202a02d"><td class="memItemLeft" align="right" valign="top">offile_off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a815432fffe399103ac661e57a202a02d">ftell</a> ()</td></tr>
<tr class="memdesc:a815432fffe399103ac661e57a202a02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtains the current value of the file position indicator for the stream pointed to by the stream.  <a href="#a815432fffe399103ac661e57a202a02d">More...</a><br/></td></tr>
<tr class="separator:a815432fffe399103ac661e57a202a02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae5a3ebce44e8423240e843a58ee9e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a2ae5a3ebce44e8423240e843a58ee9e7">fgetpos</a> (offile_fpos_t *pos)</td></tr>
<tr class="memdesc:a2ae5a3ebce44e8423240e843a58ee9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternate interface equivalent to ftell, storing the current value of the file offset into the object referenced by pos.  <a href="#a2ae5a3ebce44e8423240e843a58ee9e7">More...</a><br/></td></tr>
<tr class="separator:a2ae5a3ebce44e8423240e843a58ee9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef97cfb4f6e522220526b0187075ccb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a7ef97cfb4f6e522220526b0187075ccb">fsetpos</a> (offile_fpos_t *pos)</td></tr>
<tr class="memdesc:a7ef97cfb4f6e522220526b0187075ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternate interface equivalent to fseek (with whence set to SEEK_SET), setting the current value of the file offset from the object referenced by pos.  <a href="#a7ef97cfb4f6e522220526b0187075ccb">More...</a><br/></td></tr>
<tr class="separator:a7ef97cfb4f6e522220526b0187075ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9283787fa962471e76a0bea597bcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a80f9283787fa962471e76a0bea597bcc">fprintf</a> (const char *format,...)</td></tr>
<tr class="memdesc:a80f9283787fa962471e76a0bea597bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">print formatted string into stream, see printf(3)  <a href="#a80f9283787fa962471e76a0bea597bcc">More...</a><br/></td></tr>
<tr class="separator:a80f9283787fa962471e76a0bea597bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a2e11a9725c19831def966e40bdfaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#ae1a2e11a9725c19831def966e40bdfaa">vfprintf</a> (const char *format, va_list arg)</td></tr>
<tr class="memdesc:ae1a2e11a9725c19831def966e40bdfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">print formatted string into stream, see printf(3)  <a href="#ae1a2e11a9725c19831def966e40bdfaa">More...</a><br/></td></tr>
<tr class="separator:ae1a2e11a9725c19831def966e40bdfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa71f6857ddfdc834b8bb15777f98f7"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a3fa71f6857ddfdc834b8bb15777f98f7">file</a> ()</td></tr>
<tr class="memdesc:a3fa71f6857ddfdc834b8bb15777f98f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return FILE pointer managed by this object.  <a href="#a3fa71f6857ddfdc834b8bb15777f98f7">More...</a><br/></td></tr>
<tr class="separator:a3fa71f6857ddfdc834b8bb15777f98f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce05d3a80266ca905981e4aacc04cb5"><td class="memItemLeft" align="right" valign="top">OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a4ce05d3a80266ca905981e4aacc04cb5">open</a> () const </td></tr>
<tr class="memdesc:a4ce05d3a80266ca905981e4aacc04cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if this object is currently associated with a stream, false otherwise  <a href="#a4ce05d3a80266ca905981e4aacc04cb5">More...</a><br/></td></tr>
<tr class="separator:a4ce05d3a80266ca905981e4aacc04cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b7ceee57bd6beebaaeca8db130cf39"><td class="memItemLeft" align="right" valign="top">offile_errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#aa8b7ceee57bd6beebaaeca8db130cf39">getLastError</a> () const </td></tr>
<tr class="memdesc:aa8b7ceee57bd6beebaaeca8db130cf39"><td class="mdescLeft">&#160;</td><td class="mdescRight">return last error code for this stream  <a href="#aa8b7ceee57bd6beebaaeca8db130cf39">More...</a><br/></td></tr>
<tr class="separator:aa8b7ceee57bd6beebaaeca8db130cf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43be1c37c7acd7795cccb21f961e22aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a43be1c37c7acd7795cccb21f961e22aa">getLastErrorString</a> (<a class="el" href="classOFString.html">OFString</a> &amp;s) const </td></tr>
<tr class="memdesc:a43be1c37c7acd7795cccb21f961e22aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return string describing last error code for this stream  <a href="#a43be1c37c7acd7795cccb21f961e22aa">More...</a><br/></td></tr>
<tr class="separator:a43be1c37c7acd7795cccb21f961e22aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8111e0c517268c0aedbecf4e52b2fcd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8111e0c517268c0aedbecf4e52b2fcd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OFFile</b> (const <a class="el" href="classOFFile.html">OFFile</a> &amp;arg)</td></tr>
<tr class="separator:a8111e0c517268c0aedbecf4e52b2fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4a5a475eb7fd794cd1c1c31447fd4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c4a5a475eb7fd794cd1c1c31447fd4c"></a>
<a class="el" href="classOFFile.html">OFFile</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classOFFile.html">OFFile</a> &amp;arg)</td></tr>
<tr class="separator:a4c4a5a475eb7fd794cd1c1c31447fd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18223f82f8baf69ac5ad69beccb340c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18223f82f8baf69ac5ad69beccb340c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a18223f82f8baf69ac5ad69beccb340c0">storeLastError</a> ()</td></tr>
<tr class="memdesc:a18223f82f8baf69ac5ad69beccb340c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">store last error code. For now we simply store the content of errno. <br/></td></tr>
<tr class="separator:a18223f82f8baf69ac5ad69beccb340c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a136c8356d23f72b64d49acabc0fa797e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a136c8356d23f72b64d49acabc0fa797e"></a>
FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a136c8356d23f72b64d49acabc0fa797e">file_</a></td></tr>
<tr class="memdesc:a136c8356d23f72b64d49acabc0fa797e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the file maintained by this object <br/></td></tr>
<tr class="separator:a136c8356d23f72b64d49acabc0fa797e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d38aaad6074caeae3ff3977bc3faac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12d38aaad6074caeae3ff3977bc3faac"></a>
OFBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a12d38aaad6074caeae3ff3977bc3faac">popened_</a></td></tr>
<tr class="memdesc:a12d38aaad6074caeae3ff3977bc3faac"><td class="mdescLeft">&#160;</td><td class="mdescRight">a flag indicating whether or not this object was created with <a class="el" href="classOFFile.html#a4a8b221e6880cca98401576e7471b608" title="opens a process by creating a pipe, forking, and invoking the shell.">popen()</a>. <br/></td></tr>
<tr class="separator:a12d38aaad6074caeae3ff3977bc3faac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9780a45d12dd652f4952b17a95fca91c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9780a45d12dd652f4952b17a95fca91c"></a>
offile_errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFFile.html#a9780a45d12dd652f4952b17a95fca91c">lasterror_</a></td></tr>
<tr class="memdesc:a9780a45d12dd652f4952b17a95fca91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the last error code for operations of this stream <br/></td></tr>
<tr class="separator:a9780a45d12dd652f4952b17a95fca91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>this class provides a simple C++ encapsulation layer for stdio FILE pointers. </p>
<p>All stdio functions on files are directly mapped into member functions. The handling of large files (64 bit file systems) is transparent. Instead of type off_t, <a class="el" href="classOFFile.html#a8490f9cb1a5e7bcb6a48e12fa47b223d" title="sets the file position indicator for the stream pointed to by stream.">fseek()</a> and <a class="el" href="classOFFile.html#a815432fffe399103ac661e57a202a02d" title="obtains the current value of the file position indicator for the stream pointed to by the stream...">ftell()</a> use offile_off_t which is a 64 bit type if available on the underlying platform. Similarly, getpos() and setpos() use type offile_fpos_t, which is defined appropriately. This class provides both <a class="el" href="classOFFile.html#ae79262a03b727f2d513439901aa1a42b" title="dissociates the named stream from its underlying file or set of functions.">fclose()</a> and <a class="el" href="classOFFile.html#ac980a9c66c2342829281dc2ecebd3746" title="waits for the associated process (created with popen) to terminate and returns the exit status of the...">pclose()</a>, but these are equivalent - the code always closes pipes with <a class="el" href="classOFFile.html#ac980a9c66c2342829281dc2ecebd3746" title="waits for the associated process (created with popen) to terminate and returns the exit status of the...">pclose()</a> and files with <a class="el" href="classOFFile.html#ae79262a03b727f2d513439901aa1a42b" title="dissociates the named stream from its underlying file or set of functions.">fclose()</a>. Finally, an abstraction for errno is provided. Error codes should always be retrieves using methods <a class="el" href="classOFFile.html#aa8b7ceee57bd6beebaaeca8db130cf39" title="return last error code for this stream">getLastError()</a> and <a class="el" href="classOFFile.html#a43be1c37c7acd7795cccb21f961e22aa" title="return string describing last error code for this stream">getLastErrorString()</a> which on Unix platforms are based on errno and strerror/strerror_r, but may be based on other mechanisms on platforms where errno does not exist. </p>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00115">115</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa90c8f5310d7bc9a1c1a4f1e53853cb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFFile::OFFile </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create object for given stdio FILE </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>stdio FILE </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00124">124</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1da58c5e146ce906c5f3f429625d0275"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tests the end-of-file indicator for the stream, returning non-zero if it is set. </p>
<p>The end-of-file indicator can only be cleared by the function clearerr. This method is called eof, not feof, because feof() is a macro on some systems and, therefore, cannot be used as a method name. </p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if EOF, zero otherwise </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00371">371</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

</div>
</div>
<a class="anchor" id="a08e2b6c3af9a8a532575e5f032f3312f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tests the error indicator for the stream, returning non-zero if it is set. </p>
<p>This method is named error, not ferror, because ferror() is a macro on some systems and, therefore, cannot be used as a method name. The error indicator can only be reset by the clearerr function. </p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if error flag is set, zero otherwise </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00387">387</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

</div>
</div>
<a class="anchor" id="ae79262a03b727f2d513439901aa1a42b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fclose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dissociates the named stream from its underlying file or set of functions. </p>
<p>If the stream was being used for output, any buffered data is written first, using fflush. Independent of the return value of this method, any further access (including another call to <a class="el" href="classOFFile.html#ae79262a03b727f2d513439901aa1a42b" title="dissociates the named stream from its underlying file or set of functions.">fclose()</a>) to the stream maintained by this object results in undefined behaviour. </p>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, EOF otherwise, in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00254">254</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, <a class="el" href="offile_8h_source.html#l00283">pclose()</a>, <a class="el" href="offile_8h_source.html#l00827">popened_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00179">fdopen()</a>, <a class="el" href="offile_8h_source.html#l00139">fopen()</a>, <a class="el" href="offile_8h_source.html#l00283">pclose()</a>, <a class="el" href="offile_8h_source.html#l00196">popen()</a>, <a class="el" href="offile_8h_source.html#l00234">tmpfile()</a>, and <a class="el" href="offile_8h_source.html#l00127">~OFFile()</a>.</p>

</div>
</div>
<a class="anchor" id="aa96a6fddc1d4ba536d68dbf135f3cc84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFFile::fdopen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>associates a stream with the existing file descriptor, fildes. </p>
<p>The mode of the stream (one of the values "r", "r+", "w", "w+", "a", "a+") must be compatible with the mode of the file descriptor. The file position indicator of the new stream is set to that belong­ ing to fildes, and the error and end-of-file indicators are cleared. Modes "w" or "w+" do not cause truncation of the file. The file descriptor is not dup'ed, and will be closed when the stream created by fdopen is closed. The result of applying fdopen to a shared memory object is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>file descriptor </td></tr>
    <tr><td class="paramname">modes</td><td>"r", "w" or "a" with possible modifiers "+", "b" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if stream was successfully created, false otherwise, in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00179">179</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00254">fclose()</a>, <a class="el" href="offile_8h_source.html#l00824">file_</a>, <a class="el" href="offile_8h_source.html#l00827">popened_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

</div>
</div>
<a class="anchor" id="a02952ff58fe0edb489364f2a855547a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fflush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forces a write of all user-space buffered data for the given output or update stream via the stream's underlying write function. </p>
<p>The open status of the stream is unaffected. </p>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, EOF otherwise, in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00320">320</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00510">fseek()</a>.</p>

</div>
</div>
<a class="anchor" id="a39adaf2ef5813046ea35d6ae6cb26720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fgetc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error. </p>
<dl class="section return"><dt>Returns</dt><dd>next character from stream or EOF </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00331">331</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00331">fgetc()</a>, and <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00331">fgetc()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ae5a3ebce44e8423240e843a58ee9e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fgetpos </td>
          <td>(</td>
          <td class="paramtype">offile_fpos_t *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>alternate interface equivalent to ftell, storing the current value of the file offset into the object referenced by pos. </p>
<p>On some non-UNIX systems an fpos_t object may be a complex object and these routines may be the only way to portably reposition a text stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>pointer to offile_fpos_t structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 otherwise in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00626">626</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00510">fseek()</a>, and <a class="el" href="offile_8h_source.html#l00589">ftell()</a>.</p>

</div>
</div>
<a class="anchor" id="a25cc2da7e2d642fdcdee55296d1fd617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* OFFile::fgets </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads in at most one less than n characters from stream and stores them into the buffer pointed to by s. </p>
<p>Reading stops after an EOF or a newline. If a newline is read, it is stored into the buffer. A '\0' is stored after the last character in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to buffer of size n </td></tr>
    <tr><td class="paramname">n</td><td>buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to string </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00483">483</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00483">fgets()</a>, and <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00483">fgets()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fa71f6857ddfdc834b8bb15777f98f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* OFFile::file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return FILE pointer managed by this object. </p>
<p>This allows the user to call some stdio functions that are not encapsulated in this class (but possibly should be). </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to FILE structure managed by this object </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00692">692</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

</div>
</div>
<a class="anchor" id="a40babba8564844702f59c68319ffa70d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fileNo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the low-level file descriptor associated with the stream. </p>
<p>The spelling of this member function is different from stdio fileno() because on some systems (such as MinGW) fileno() is a macro and, therefore, cannot be used as a method name. </p>
<dl class="section return"><dt>Returns</dt><dd>low-level file descriptor associated with stream </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00406">406</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

</div>
</div>
<a class="anchor" id="a36564e09a6be8503428df807cbef97cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFFile::fopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>opens the file whose name is the string pointed to by path and associates a stream with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>path to file </td></tr>
    <tr><td class="paramname">modes</td><td>"r", "w" or "a" with possible modifiers "+", "b" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if stream was successfully created, false otherwise, in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00139">139</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00254">fclose()</a>, <a class="el" href="offile_8h_source.html#l00824">file_</a>, <a class="el" href="offile_8h_source.html#l00827">popened_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

</div>
</div>
<a class="anchor" id="a80f9283787fa962471e76a0bea597bcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print formatted string into stream, see printf(3) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>format string </td></tr>
    <tr><td class="paramname">...</td><td>further parameters according to format string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters printed </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00664">664</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00679">vfprintf()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6002d5e252256817bc0135a2dc2d785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fputc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes the character c, cast to an unsigned char, to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the character written as an unsigned char cast to an int or EOF on error </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00473">473</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00473">fputc()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00473">fputc()</a>.</p>

</div>
</div>
<a class="anchor" id="a9731ef2d8d2cd55c5bbbea0eabe0f490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fputs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes the string s to stream, without its trailing '\0'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-negative number on success, or EOF on error. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00489">489</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00489">fputs()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00489">fputs()</a>.</p>

</div>
</div>
<a class="anchor" id="a117df6d307708c831f533a2e512544c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFFile::fread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads n elements of data, each size bytes long, from the stream, storing them at the location given by ptr. </p>
<p>Returns the number of items successfully read (i.e., not the number of characters). If an error occurs, or the end-of-file is reached, the return value is a short item count (or zero). fread does not distinguish between end-of-file and error, and callers must use feof and ferror to determine which occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of item </td></tr>
    <tr><td class="paramname">n</td><td>number of items </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of items read </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00310">310</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

</div>
</div>
<a class="anchor" id="a215079f052d70a05f2de33277d949374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFFile::freopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>opens the file whose name is the string pointed to by path and associates the stream pointed maintained by this object with it. </p>
<p>The original stream (if it exists) is closed. The mode argument is used just as in the fopen function. The primary use of the freopen function is to change the file associated with a standard text stream (stderr, stdin, or stdout). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>path to file </td></tr>
    <tr><td class="paramname">modes</td><td>"r", "w" or "a" with possible modifiers "+", "b" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if stream was successfully created, false otherwise, in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00217">217</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, <a class="el" href="offile_8h_source.html#l00827">popened_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

</div>
</div>
<a class="anchor" id="a8490f9cb1a5e7bcb6a48e12fa47b223d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fseek </td>
          <td>(</td>
          <td class="paramtype">offile_off_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the file position indicator for the stream pointed to by stream. </p>
<p>The new position, measured in bytes, is obtained by adding offset bytes to the position specified by whence. If whence is set to SEEK_SET, SEEK_CUR, or SEEK_END, the offset is relative to the start of the file, the current position indicator, or end-of-file, respectively. A successful call to the fseek function clears the end-of- file indicator for the stream and undoes any effects of the ungetc function on the same stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>offset to seek to </td></tr>
    <tr><td class="paramname">whence</td><td>SEEK_SET, SEEK_CUR, or SEEK_END </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 otherwise in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00510">510</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00320">fflush()</a>, <a class="el" href="offile_8h_source.html#l00626">fgetpos()</a>, <a class="el" href="offile_8h_source.html#l00824">file_</a>, <a class="el" href="offile_8h_source.html#l00646">fsetpos()</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ef97cfb4f6e522220526b0187075ccb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::fsetpos </td>
          <td>(</td>
          <td class="paramtype">offile_fpos_t *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>alternate interface equivalent to fseek (with whence set to SEEK_SET), setting the current value of the file offset from the object referenced by pos. </p>
<p>On some non-UNIX systems an fpos_t object may be a complex object and these routines may be the only way to portably reposition a text stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>pointer to offile_fpos_t structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, -1 otherwise in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00646">646</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00510">fseek()</a>.</p>

</div>
</div>
<a class="anchor" id="a815432fffe399103ac661e57a202a02d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">offile_off_t OFFile::ftell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>obtains the current value of the file position indicator for the stream pointed to by the stream. </p>
<dl class="section return"><dt>Returns</dt><dd>current file position </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00589">589</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00626">fgetpos()</a>, <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

</div>
</div>
<a class="anchor" id="adb22aa9a65956d6d1ddf560bfb1c3305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OFFile::fwrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes n elements of data, each size bytes long, to the stream, obtaining them from the location given by ptr. </p>
<p>Returns the number of items successfully written (i.e., not the number of characters). If an error occurs the return value is a short item count (or zero). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of item </td></tr>
    <tr><td class="paramname">n</td><td>number of items </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of items written </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00294">294</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

</div>
</div>
<a class="anchor" id="aa8b7ceee57bd6beebaaeca8db130cf39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">offile_errno_t OFFile::getLastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return last error code for this stream </p>
<dl class="section return"><dt>Returns</dt><dd>last error code for this stream </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00702">702</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00830">lasterror_</a>.</p>

</div>
</div>
<a class="anchor" id="a43be1c37c7acd7795cccb21f961e22aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFFile::getLastErrorString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFString.html">OFString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return string describing last error code for this stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string describing last error code for this stream returned in this parameter </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00707">707</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00830">lasterror_</a>, and <a class="el" href="classOFStandard.html#ad29b92d97c56b8f42dcdf011abfcf201">OFStandard::strerror()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ce05d3a80266ca905981e4aacc04cb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFFile::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if this object is currently associated with a stream, false otherwise </p>
<dl class="section return"><dt>Returns</dt><dd>true if this object is currently associated with a stream, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00697">697</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

</div>
</div>
<a class="anchor" id="ac980a9c66c2342829281dc2ecebd3746"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::pclose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>waits for the associated process (created with popen) to terminate and returns the exit status of the command as returned by wait4. </p>
<p>In this implementation, fclose and pclose can be used synonymously. </p>
<dl class="section return"><dt>Returns</dt><dd>process ID of the child which exited, or -1 on error, in which case the error code is set </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00283">283</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00254">fclose()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00254">fclose()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a8b221e6880cca98401576e7471b608"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFFile::popen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>opens a process by creating a pipe, forking, and invoking the shell. </p>
<p>Since a pipe is by definition unidirectional, the type argument may specify only reading or writing, not both; the resulting stream is correspondingly read-only or write-only. If the object was already associated with another file or pipe, that one is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>shell command line </td></tr>
    <tr><td class="paramname">modes</td><td>"r" or "w" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pipe was successfully created, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00196">196</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00254">fclose()</a>, <a class="el" href="offile_8h_source.html#l00824">file_</a>, <a class="el" href="offile_8h_source.html#l00827">popened_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

</div>
</div>
<a class="anchor" id="a457f04cf811c27fd3377889c7cbf80b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFFile::rewind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the file position indicator for the stream pointed to by stream to the beginning of the file. </p>
<p>This is equivalent to fseek(0, SEEK_SET) except that the error indicator for the stream is also cleared. </p>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00359">359</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00359">rewind()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00359">rewind()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6ef2f0399a1a579826425c6a8f11c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFFile::setbuf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The three types of buffering available are unbuffered, block buffered, and line buffered. </p>
<p>When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically stdin). Normally all files are block buffered. if a stream refers to a terminal (as stdout normally does) it is line buffered. The standard error stream stderr is always unbuffered by default. This function allows to set the mode of the stream to unbuffered (if buf is NULL) or block buffered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to buffer of size BUFSIZ as declared in cstdio, or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, nonzero otherwise, in which case the error code may be set </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00422">422</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00422">setbuf()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00422">setbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="a023488d2b4d6aced48c10700837377cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFFile::setbuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The three types of buffering available are unbuffered, block buffered, and line buffered. </p>
<p>When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically stdin). Normally all files are block buffered. if a stream refers to a terminal (as stdout normally does) it is line buffered. The standard error stream stderr is always unbuffered by default. This function allows to set the mode of the stream to unbuffered (if buf is NULL) or block buffered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, nonzero otherwise, in which case the error code may be set </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00460">460</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00439">setvbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="a5aaed3df732322469e7cff3076c7437d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFFile::setlinebuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The three types of buffering available are unbuffered, block buffered, and line buffered. </p>
<p>When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically stdin). Normally all files are block buffered. if a stream refers to a terminal (as stdout normally does) it is line buffered. The standard error stream stderr is always unbuffered by default. this function allows to set the mode of the stream to line buffered. </p>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, nonzero otherwise, in which case the error code may be set </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00346">346</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00439">setvbuf()</a>.</p>

</div>
</div>
<a class="anchor" id="aa90ebe1b031b5e3b442096665c9634b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::setvbuf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The three types of buffering available are unbuffered, block buffered, and line buffered. </p>
<p>When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically stdin). Normally all files are block buffered. if a stream refers to a terminal (as stdout normally does) it is line buffered. The standard error stream stderr is always unbuffered by default. This function allows to set the stream mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to buffer, may be NULL </td></tr>
    <tr><td class="paramname">modes</td><td>_IONBF (unbuffered) _IOLBF (line buffered) or _IOFBF (fully buffered) </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success, nonzero otherwise, in which case the error code may be set </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00439">439</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00460">setbuffer()</a>, and <a class="el" href="offile_8h_source.html#l00346">setlinebuf()</a>.</p>

</div>
</div>
<a class="anchor" id="a907499068d112855bd00ec98f52df09e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFBool OFFile::tmpfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generates a unique temporary filename. </p>
<p>The temporary file is then opened in binary read/write (w+b) mode. The file will be automatically deleted when it is closed or the program terminates normally. </p>
<dl class="section return"><dt>Returns</dt><dd>true if stream was successfully created, false otherwise, in which case the error code is set. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00234">234</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00254">fclose()</a>, <a class="el" href="offile_8h_source.html#l00824">file_</a>, <a class="el" href="offile_8h_source.html#l00827">popened_</a>, and <a class="el" href="offile_8h_source.html#l00833">storeLastError()</a>.</p>

</div>
</div>
<a class="anchor" id="a7201dcb91429151a508bd1ebc38127d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::ungetc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pushes c back to stream, cast to unsigned char, where it is available for subsequent read operations. </p>
<p>Pushed - back characters will be returned in reverse order; only one pushback is guaranteed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>character to push back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>c on success, or EOF on error. </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00497">497</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>, and <a class="el" href="offile_8h_source.html#l00497">ungetc()</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00497">ungetc()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1a2e11a9725c19831def966e40bdfaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OFFile::vfprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print formatted string into stream, see printf(3) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>format string </td></tr>
    <tr><td class="paramname">arg</td><td>list of further parameters according to format string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters printed </dd></dl>

<p>Definition at line <a class="el" href="offile_8h_source.html#l00679">679</a> of file <a class="el" href="offile_8h_source.html">offile.h</a>.</p>

<p>References <a class="el" href="offile_8h_source.html#l00824">file_</a>.</p>

<p>Referenced by <a class="el" href="offile_8h_source.html#l00664">fprintf()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>F:/Projects/GigaVoxels/Livraison_GV/ThirdDependencies/windows-VS2013-x64/dcmtk-3.6.0_VS2013/ofstd/include/dcmtk/ofstd/<a class="el" href="offile_8h_source.html">offile.h</a></li>
</ul>
</div><!-- contents -->
<p>
<hr>
<small>
Generated on Thu Jul 23 2015 for <a href="http://dicom.offis.de/dcmtk">OFFIS DCMTK</a> Version 3.6.0 by <a href="http://www.doxygen.org/">Doxygen</a> 1.8.3.1
</small>
