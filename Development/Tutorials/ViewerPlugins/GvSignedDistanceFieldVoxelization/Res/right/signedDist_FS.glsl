////////////////////////////////////////////////////////////////////////////////
//
// FRAGMENT SHADER
//
// ...
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// VERSION
////////////////////////////////////////////////////////////////////////////////

#version 420

////////////////////////////////////////////////////////////////////////////////
// EXTENSIONS
////////////////////////////////////////////////////////////////////////////////

#extension GL_EXT_shader_image_load_store : enable

////////////////////////////////////////////////////////////////////////////////
// INPUT
////////////////////////////////////////////////////////////////////////////////

// Input data structure
in Data
{
	// ...
	float distMin;

	// ...
	vec3 normal;

} dataIn;

////////////////////////////////////////////////////////////////////////////////
// UNIFORM
////////////////////////////////////////////////////////////////////////////////

uniform int uSlice;

// To know along whitch axis we are working
uniform int uAxe;

uniform layout( r32ui ) coherent volatile uimage3D uDistance[ 3 ];

////////////////////////////////////////////////////////////////////////////////
// OUTPUT
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function that put distance in the texture, emulating atomic operation
////////////////////////////////////////////////////////////////////////////////
void atomicPutDist( layout( r32ui ) coherent volatile uimage3D image, ivec3 coords, float val, float sign )
{
	// Produce the encoding of a floating point value as an integer
	uint newVal = floatBitsToUint( val );

	uint prevVal = 0;
	uint curVal;
	float aux;

	// Loop as long as destination value gets changed by other threads
	while ( ( curVal = imageAtomicCompSwap( image, coords, prevVal, newVal ) ) != prevVal )
	{
		prevVal = curVal;
		aux = min( abs( uintBitsToFloat( curVal ) ), val );
		if ( aux == val )
		{
			// We change the value only if val is the min
			newVal = floatBitsToUint( sign * val );
		}
		else
		{
			newVal = curVal;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// PROGRAM
////////////////////////////////////////////////////////////////////////////////
void main()
{
	// -1 if we are inside the mesh, the sign is computed thank to the normal
	float signe;

	if ( uAxe == 0 )
	{
		signe = - sign( dataIn.normal.x * dataIn.distMin );
		atomicPutDist( uDistance[ uAxe ], ivec3( uSlice, gl_FragCoord.x, gl_FragCoord.y ), abs( dataIn.distMin ), signe );
	}
	
	if ( uAxe == 1 )
	{
		signe = - sign( dataIn.normal.y * dataIn.distMin );
		atomicPutDist( uDistance[ uAxe ], ivec3( gl_FragCoord.y, uSlice, gl_FragCoord.x ), abs( dataIn.distMin ), signe );
	}

	if ( uAxe == 2 )
	{
		signe = - sign( dataIn.normal.z * dataIn.distMin );
		atomicPutDist( uDistance[ uAxe ], ivec3( gl_FragCoord.x, gl_FragCoord.y, uSlice ), abs( dataIn.distMin ), signe );
	}
}
