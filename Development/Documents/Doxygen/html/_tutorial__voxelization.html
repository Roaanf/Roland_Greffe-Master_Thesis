<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GigaSpace: Voxelization Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GigaSpace<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_tutorial__voxelization.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Voxelization Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="GigaVoxelsLogo_div2.png" alt=""/>
</div>
<h1><a class="anchor" id="Overview_Section"></a>
Overview</h1>
<p>This example shows how to write a custom Data Production Management to voxelize a mesh "on the fly".</p>
<p><br  />
 The main themes related to this tutorial are :</p><ul>
<li>mesh voxelization</li>
<li>OpenGL graphics interoperability</li>
<li>reading/writing to textures with OpenGL (GLSL shader programs)</li>
</ul>
<p><br  />
 </p><div class="image">
<img src="voxelization_image_01.png" alt=""/>
<div class="caption">
A voxelized mesh</div></div>
<p><br  />
 </p><hr  />
<h1><a class="anchor" id="Tutorial_Voxelization_Mandatory_Section"></a>
Recommandation</h1>
<p>FIRST, assure you have read the basic programming scheme of GigaVoxels available in the <a class="el" href="_library__how_to_program__the_basics__page.html">Programmation : The Basics</a> section. <br  />
</p>
<p>The associated GigaVoxels pipeline is mainly based on a Host Producer that writes data in a memory "mapped" buffer. The associated Kernel Producer reads this buffer to update the cache on Device. The Host Producer has been modified to write data in the Data Pool with the help of a GLSL program used to do mesh voxelization on the fly. <br  />
 </p><hr  />
<h1><a class="anchor" id="UMLDesign_Section"></a>
UML Design</h1>
<p>The following screenshot is a simplified class Diagram of the classes used in this tutorial.</p>
<p>Different colors are used to ease comprehension :</p><ul>
<li>RED : third party dependency classes (QGLViewer, Loki, etc...)</li>
<li>BLUE : GigaVoxels classes</li>
<li>YELLOW : user HOST classes</li>
<li>GREEN : user DEVICE classes</li>
</ul>
<p>The <a class="el" href="class_sample_core.html" title="The SampleCore class provides...">SampleCore</a> class is the main GigaVoxels pipeline containing :</p><ul>
<li>the GigaVoxels COMMON classes <ul>
<li>DATA STRUCTURE : the sparse voxel octree structure GvStructure::GvVolumeTree </li>
<li>CACHE : the cache manager system GvStructure::GvVolumeTreeCache </li>
<li>RENDERER : the ray-casting renderer GvRenderer::VolumeTreeRendererCUDA</li>
</ul>
</li>
<li>the USER defined classes <ul>
<li>PRODUCER : a host SphereProducer with its associated device-side SphereProducerKernel </li>
<li>SHADER : a host SphereShader with its associated device-side SphereShaderKernel</li>
</ul>
<br  />
 <div class="image">
<img src="UML_SimpleSphereDemo.png" alt=""/>
<div class="caption">
UML class diagram</div></div>
</li>
</ul>
<p><br  />
</p>
<p>QGLViewer and ManipulatedFrame are IHM classes to create a 3D window and a light interactor.</p>
<p><br  />
 </p><hr  />
<h1><a class="anchor" id="Tutorial_Simple_Sphere_DataStructure"></a>
Data Structure</h1>
<p>The content of a voxel is represented by two channels :</p><ul>
<li>one for RGBA colors (uchar4 type),</li>
<li>and one for normals (<a class="el" href="structhalf4.html">half4</a> type).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Loki::TL::MakeTypelist&lt; uchar4, half4 &gt;::Result <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#aa8b648ffe4e2439cdc08628a865fea88">DataType</a>;</div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_aa8b648ffe4e2439cdc08628a865fea88"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#aa8b648ffe4e2439cdc08628a865fea88">DataType</a></div><div class="ttdeci">Loki::TL::MakeTypelist&lt; uchar4 &gt;::Result DataType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:108</div></div>
</div><!-- fragment --><p>The data structre is an octree (2x2x2) defined by : </p><div class="fragment"><div class="line"><span class="comment">// Defines the size of a node tile</span></div>
<div class="line"><span class="keyword">typedef</span> gigavoxels::StaticRes1D&lt; 2 &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#abe7051c9145b1528b0bef0b71fbd4cd9">NodeRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the size of a brick</span></div>
<div class="line"><span class="keyword">typedef</span> gigavoxels::StaticRes1D&lt; 8 &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a8d82930cf37033df572379c6e7145622">BrickRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the size of the border around a brick</span></div>
<div class="line"><span class="keyword">enum</span> { <a class="code hl_enumvalue" href="_gs_pipeline_manager_8h.html#a0ed680fdb405e7195d9f14032851eebba9ed6d36d6d289c0cc9dd125a67bb9b05">BrickBorderSize</a> = 1 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the total size of a brick</span></div>
<div class="line"><span class="keyword">typedef</span> gigavoxels::StaticRes1D&lt; 8 + 2 * BrickBorderSize &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a35118e342dd46bf939d0d081ccfb0790">RealBrickRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of structure we want to use. Array3DGPUTex is the type of array used to store the bricks.</span></div>
<div class="line"><span class="keyword">typedef</span> gigavoxels::VolumeTree&lt; DataType, gigavoxels::Array3DGPUTex, NodeRes, BrickRes, BrickBorderSize &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a220dd4c5ffb4712bcd1fce92f46e779e">VolumeTreeType</a>;</div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a0ed680fdb405e7195d9f14032851eebba9ed6d36d6d289c0cc9dd125a67bb9b05"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a0ed680fdb405e7195d9f14032851eebba9ed6d36d6d289c0cc9dd125a67bb9b05">BrickBorderSize</a></div><div class="ttdeci">@ BrickBorderSize</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:117</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a220dd4c5ffb4712bcd1fce92f46e779e"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a220dd4c5ffb4712bcd1fce92f46e779e">VolumeTreeType</a></div><div class="ttdeci">GvStructure::GsVolumeTree&lt; DataType, NodeRes, BrickRes, BrickBorderSize &gt; VolumeTreeType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:131</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a35118e342dd46bf939d0d081ccfb0790"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a35118e342dd46bf939d0d081ccfb0790">RealBrickRes</a></div><div class="ttdeci">GvCore::GsVec1D&lt; 8+2 *BrickBorderSize &gt; RealBrickRes</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:120</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a8d82930cf37033df572379c6e7145622"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a8d82930cf37033df572379c6e7145622">BrickRes</a></div><div class="ttdeci">GvCore::GsVec1D&lt; 8 &gt; BrickRes</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:114</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_abe7051c9145b1528b0bef0b71fbd4cd9"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#abe7051c9145b1528b0bef0b71fbd4cd9">NodeRes</a></div><div class="ttdeci">GvCore::GsVec1D&lt; 2 &gt; NodeRes</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:111</div></div>
</div><!-- fragment --><p><br  />
 Now let's have a look at the SphereProducerKernal code. As said before, users have to write a produceData() method for each of the two channel :</p><ul>
<li>node tiles,</li>
<li>bricks of voxels.</li>
</ul>
<p><br  />
 </p><hr  />
 <h1><a class="anchor" id="Tutorial_Simple_Sphere_Node_Tiles_Production"></a>
Node tiles production</h1>
<p>In this section, we detail code to explain how to produce nodes.</p>
<div class="fragment"><div class="line"><span class="comment"> /******************************************************************************</span></div>
<div class="line"><span class="comment">   Produce data on device.</span></div>
<div class="line"><span class="comment">   Implement the produceData method for the channel 0 (nodes)</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   Producing data mecanism works element by element (node tile or brick) depending on the channel.</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   In the function, user has to produce data for a node tile or a brick of voxels :</span></div>
<div class="line"><span class="comment">   - for a node tile, user has to defined regions (i.e nodes) where lies data, constant values,</span></div>
<div class="line"><span class="comment">   etc...</span></div>
<div class="line"><span class="comment">   - for a brick, user has to produce data (i.e voxels) at for each of the channels</span></div>
<div class="line"><span class="comment">   user had previously defined (color, normal, density, etc...)</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @param pGpuPool The device side pool (nodes or bricks)</span></div>
<div class="line"><span class="comment">   @param pRequestID The current processed element coming from the data requests list (a node tile or a brick)</span></div>
<div class="line"><span class="comment">   @param pProcessID Index of one of the elements inside a node tile or a voxel bricks</span></div>
<div class="line"><span class="comment">   @param pNewElemAddress The address at which to write the produced data in the pool</span></div>
<div class="line"><span class="comment">   @param pParentLocInfo The localization info used to locate an element in the pool</span></div>
<div class="line"><span class="comment">   @param Loki::Int2Type&lt; 0 &gt; corresponds to the index of the node pool</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @return A feedback value that the user can return.</span></div>
<div class="line"><span class="comment">                                                                               /</span></div>
<div class="line"><span class="comment">template&lt; typename NodeRes, typename BrickRes, uint BorderSize, typename VolTreeKernelType &gt;</span></div>
<div class="line"><span class="comment">template&lt; typename GPUPoolKernelType &gt;</span></div>
<div class="line"><span class="comment">__device__</span></div>
<div class="line"><span class="comment">inline uint SphereProducerKernel&lt; NodeRes, BrickRes, BorderSize, VolTreeKernelType &gt;</span></div>
<div class="line"><span class="comment">::produceData( GPUPoolKernelType&amp; nodePool, uint requestID, uint processID, uint3 newElemAddress,</span></div>
<div class="line"><span class="comment">                          const GvCore::GvLocalizationInfo&amp; parentLocInfo, Loki::Int2Type&lt; 0 &gt; )</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">        // NOTE :</span></div>
<div class="line"><span class="comment">        // In this method, you are inside a node tile.</span></div>
<div class="line"><span class="comment">        // The goal is to determine, for each node of the node tile, which type of data it holds.</span></div>
<div class="line"><span class="comment">        // Data type can be :</span></div>
<div class="line"><span class="comment">        // - a constant region,</span></div>
<div class="line"><span class="comment">        // - a region with data,</span></div>
<div class="line"><span class="comment">        // - a region where max resolution is reached.</span></div>
<div class="line"><span class="comment">        // So, one thread is responsible of the production of one node of a node tile.</span></div>
<div class="line"><span class="comment">        </span></div>
<div class="line"><span class="comment">        // Retrieve current node tile localization information code and depth</span></div>
<div class="line"><span class="comment">        const GvCore::GvLocalizationInfo::CodeType parentLocCode = parentLocInfo.locCode;</span></div>
<div class="line"><span class="comment">        const GvCore::GvLocalizationInfo::DepthType parentLocDepth = parentLocInfo.locDepth;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        // Process ID gives the 1D index of a node in the current node tile</span></div>
<div class="line"><span class="comment">        if ( processID &lt; NodeRes::getNumElements() )</span></div>
<div class="line"><span class="comment">        {</span></div>
<div class="line"><span class="comment">                // First, compute the 3D offset of the node in the node tile</span></div>
<div class="line"><span class="comment">                uint3 subOffset = NodeRes::toFloat3( processID );</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">                // Node production corresponds to subdivide a node tile.</span></div>
<div class="line"><span class="comment">                // So, based on the index of the node, find the node child.</span></div>
<div class="line"><span class="comment">                // As we want to sudbivide the curent node, we retrieve localization information</span></div>
<div class="line"><span class="comment">                // at the next level</span></div>
<div class="line"><span class="comment">                uint3 regionCoords = parentLocCode.addLevel&lt; NodeRes &gt;( subOffset ).get();</span></div>
<div class="line"><span class="comment">                uint regionDepth = parentLocDepth.addLevel().get();</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">                // Create a new node for which you will have to fill its information.</span></div>
<div class="line"><span class="comment">                GvStructure::OctreeNode newnode;</span></div>
<div class="line"><span class="comment">                newnode.childAddress = 0;</span></div>
<div class="line"><span class="comment">                newnode.brickAddress = 0;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">                // Call what we call an oracle that will determine the type of the region of the node accordingly</span></div>
<div class="line"><span class="comment">                GPUVoxelProducer::GPUVPRegionInfo nodeinfo = getRegionInfo( regionCoords, regionDepth );</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">                // Now that the type of the region is found, fill the new node information</span></div>
<div class="line"><span class="comment">                if ( nodeinfo == GPUVoxelProducer::GPUVP_CONSTANT )</span></div>
<div class="line"><span class="comment">                {</span></div>
<div class="line"><span class="comment">                        newnode.setTerminal( true );</span></div>
<div class="line"><span class="comment">                }</span></div>
<div class="line"><span class="comment">                else if ( nodeinfo == GPUVoxelProducer::GPUVP_DATA )</span></div>
<div class="line"><span class="comment">                {</span></div>
<div class="line"><span class="comment">                        newnode.setStoreBrick();</span></div>
<div class="line"><span class="comment">                        newnode.setTerminal( false );</span></div>
<div class="line"><span class="comment">                }</span></div>
<div class="line"><span class="comment">                else if ( nodeinfo == GPUVoxelProducer::GPUVP_DATA_MAXRES )</span></div>
<div class="line"><span class="comment">                {</span></div>
<div class="line"><span class="comment">                        newnode.setStoreBrick();</span></div>
<div class="line"><span class="comment">                        newnode.setTerminal( true );</span></div>
<div class="line"><span class="comment">                }</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">                // Finally, write the new node information into the node pool by selecting channels :</span></div>
<div class="line"><span class="comment">                // - Loki::Int2Type&lt; 0 &gt;() points to node information</span></div>
<div class="line"><span class="comment">                // - Loki::Int2Type&lt; 1 &gt;() points to brick information</span></div>
<div class="line"><span class="comment">                //</span></div>
<div class="line"><span class="comment">                // newElemAddress.x + processID : is the adress of the new node in the node pool</span></div>
<div class="line"><span class="comment">                nodePool.getChannel( Loki::Int2Type&lt; 0 &gt;() ).set( newElemAddress.x + processID, newnode.childAddress );</span></div>
<div class="line"><span class="comment">                nodePool.getChannel( Loki::Int2Type&lt; 1 &gt;() ).set( newElemAddress.x + processID, newnode.brickAddress );</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        return 0;</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p><br  />
</p>
<p>In the following, details the oracle part where regions of space are analysed to determine wheter or not it contains data.</p>
<div class="fragment"><div class="line"><span class="comment"> /******************************************************************************</span></div>
<div class="line"><span class="comment">   Helper function used to determine the type of zones in the data structure.</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   The data structure is made of regions containing data, empty or constant regions.</span></div>
<div class="line"><span class="comment">   Besides, this function can tell if the maximum resolution is reached in a region.</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @param regionCoords region coordinates</span></div>
<div class="line"><span class="comment">   @param regionDepth region deptj</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @return the type of the region</span></div>
<div class="line"><span class="comment">                                                                               /</span></div>
<div class="line"><span class="comment">template&lt; typename NodeRes, typename BrickRes, uint BorderSize, typename VolTreeKernelType &gt;</span></div>
<div class="line"><span class="comment">__device__</span></div>
<div class="line"><span class="comment">inline GPUVoxelProducer::GPUVPRegionInfo SphereProducerKernel&lt; NodeRes, BrickRes, BorderSize, VolTreeKernelType &gt;</span></div>
<div class="line"><span class="comment">::getRegionInfo( uint3 regionCoords, uint regionDepth )</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">        // Limit the depth</span></div>
<div class="line"><span class="comment">        if ( regionDepth &gt;= 32 )</span></div>
<div class="line"><span class="comment">        {</span></div>
<div class="line"><span class="comment">                return GPUVoxelProducer::GPUVP_DATA_MAXRES;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        // Shared memory declaration</span></div>
<div class="line"><span class="comment">        __shared__ uint3 brickRes;</span></div>
<div class="line"><span class="comment">        __shared__ float3 brickSize;</span></div>
<div class="line"><span class="comment">        __shared__ uint3 levelRes;</span></div>
<div class="line"><span class="comment">        __shared__ float3 levelResInv;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        brickRes = BrickRes::get();</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        levelRes = make_uint3( 1 &lt;&lt; regionDepth ) * brickRes;</span></div>
<div class="line"><span class="comment">        levelResInv = make_float3( 1.f ) / make_float3( levelRes );</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        int3 brickPos = make_int3(regionCoords * brickRes) - BorderSize;</span></div>
<div class="line"><span class="comment">        float3 brickPosF = make_float3( brickPos ) * levelResInv;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        // Since we work in the range [-1;1] below, the brick size is two time bigger</span></div>
<div class="line"><span class="comment">        brickSize = make_float3( 1.f ) / make_float3( 1 &lt;&lt; regionDepth ) * 2.f;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        // Test if any of the eight brick corner lie in the sphere</span></div>
<div class="line"><span class="comment">        float3 q000 = make_float3( regionCoords * brickRes ) * levelResInv * 2.f - 1.f;</span></div>
<div class="line"><span class="comment">        float3 q001 = make_float3( q000.x + brickSize.x, q000.y,                           q000.z);</span></div>
<div class="line"><span class="comment">        float3 q010 = make_float3( q000.x,                               q000.y + brickSize.y, q000.z);</span></div>
<div class="line"><span class="comment">        float3 q011 = make_float3( q000.x + brickSize.x, q000.y + brickSize.y, q000.z);</span></div>
<div class="line"><span class="comment">        float3 q100 = make_float3( q000.x,                               q000.y,                           q000.z + brickSize.z);</span></div>
<div class="line"><span class="comment">        float3 q101 = make_float3( q000.x + brickSize.x, q000.y,                           q000.z + brickSize.z);</span></div>
<div class="line"><span class="comment">        float3 q110 = make_float3( q000.x,                               q000.y + brickSize.y, q000.z + brickSize.z);</span></div>
<div class="line"><span class="comment">        float3 q111 = make_float3( q000.x + brickSize.x, q000.y + brickSize.y, q000.z + brickSize.z);</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        if ( isInSphere( q000 ) || isInSphere( q001 ) || isInSphere( q010 ) || isInSphere( q011 ) ||</span></div>
<div class="line"><span class="comment">                isInSphere( q100 ) || isInSphere( q101 ) || isInSphere( q110 ) || isInSphere( q111 ) )</span></div>
<div class="line"><span class="comment">        {</span></div>
<div class="line"><span class="comment">                return GPUVoxelProducer::GPUVP_DATA;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">        return GPUVoxelProducer::GPUVP_CONSTANT;</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p><br  />
</p>
<p>Here is a simple helper function to test if a point is in a sphere.</p>
<div class="fragment"><div class="line"><span class="comment"> /******************************************************************************</span></div>
<div class="line"><span class="comment">   Helper class to test if a point is inside the unit sphere centered in [0,0,0]</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @param pPoint the point to test</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @return flag to tell wheter or not the point is insied the sphere</span></div>
<div class="line"><span class="comment">                                                                               /</span></div>
<div class="line"><span class="comment">__device__</span></div>
<div class="line"><span class="comment">inline bool isInSphere( float3 pPoint )</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">        return ( length( pPoint ) &lt; 1.f );</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p><br  />
 </p><hr  />
 <h1><a class="anchor" id="Tutorial_Simple_Sphere_Brick_Of_Voxels"></a>
Brick of voxels production</h1>
<p>In this section, we detail code to explain how to produce bricks of voxels.</p>
<div class="fragment"><div class="line"><span class="comment"> /******************************************************************************</span></div>
<div class="line"><span class="comment">   Produce data on device.</span></div>
<div class="line"><span class="comment">   Implement the produceData method for the channel 1 (bricks)</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   Producing data mecanism works element by element (node tile or brick) depending on the channel.</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   In the function, user has to produce data for a node tile or a brick of voxels :</span></div>
<div class="line"><span class="comment">   - for a node tile, user has to defined regions (i.e nodes) where lies data, constant values,</span></div>
<div class="line"><span class="comment">   etc...</span></div>
<div class="line"><span class="comment">   - for a brick, user has to produce data (i.e voxels) at for each of the channels</span></div>
<div class="line"><span class="comment">   user had previously defined (color, normal, density, etc...)</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @param pGpuPool The device side pool (nodes or bricks)</span></div>
<div class="line"><span class="comment">   @param pRequestID The current processed element coming from the data requests list (a node tile or a brick)</span></div>
<div class="line"><span class="comment">   @param pProcessID Index of one of the elements inside a node tile or a voxel bricks</span></div>
<div class="line"><span class="comment">   @param pNewElemAddress The address at which to write the produced data in the pool</span></div>
<div class="line"><span class="comment">   @param pParentLocInfo The localization info used to locate an element in the pool</span></div>
<div class="line"><span class="comment">   @param Loki::Int2Type&lt; 1 &gt; corresponds to the index of the brick pool</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @return A feedback value that the user can return.</span></div>
<div class="line"><span class="comment">                                                                               /</span></div>
<div class="line"><span class="comment">template&lt; typename NodeRes, typename BrickRes, uint BorderSize, typename VolTreeKernelType &gt;</span></div>
<div class="line"><span class="comment">template&lt; typename GPUPoolKernelType &gt;</span></div>
<div class="line"><span class="comment">__device__</span></div>
<div class="line"><span class="comment">inline uint SphereProducerKernel&lt; NodeRes, BrickRes, BorderSize, VolTreeKernelType &gt;</span></div>
<div class="line"><span class="comment">::produceData( GPUPoolKernelType&amp; dataPool, uint requestID, uint processID, uint3 newElemAddress,</span></div>
<div class="line"><span class="comment">                          const GvCore::GvLocalizationInfo&amp; parentLocInfo, Loki::Int2Type&lt; 1 &gt; )</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">        return 0;</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p><br  />
</p>
<p>Here is the GLSL Fragment Shader program used by the Host Producer</p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment">   FRAGMENT shader</span></div>
<div class="line"><span class="comment">                                                                               /</span></div>
<div class="line"><span class="comment">  void main()</span></div>
<div class="line"><span class="comment">  {</span></div>
<div class="line"><span class="comment">      if ( atomicCounter( uCounter ) == 0 )</span></div>
<div class="line"><span class="comment">      {</span></div>
<div class="line"><span class="comment">          atomicCounterIncrement( uCounter );</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">       </span></div>
<div class="line"><span class="comment">      // We compute voxel offset</span></div>
<div class="line"><span class="comment">      vec3 brickCoord = /*nbElementsInBrick*/</span>10.0 * ( uBrickMatrix * vec4( iData.worldPosition, 1.0 ) ).xyz;</div>
<div class="line"> </div>
<div class="line">      ivec3 voxelOffset;</div>
<div class="line">      voxelOffset.xy = ivec2( floor( brickCoord.xy ) );</div>
<div class="line">      voxelOffset.z = int( floor( brickCoord.z ) );</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// imageAtomicAdd()</span></div>
<div class="line">      <span class="comment">// - atomically add a value to an existing value in memory and return the original value</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">// &quot;uBrickAddress&quot; is the index of the brick in the cache (i.e. data pool)</span></div>
<div class="line">      <span class="comment">// so &quot;uBrickAddress * 10&quot; is the index of the equivalent voxel in the cache</span></div>
<div class="line">      imageAtomicAdd( <span class="comment">/*image*/</span>uDataPoolx, <span class="comment">/*coordinate*/</span>uBrickAddress * 10 + voxelOffset, <span class="comment">/*data*/</span>iData.normal.x );</div>
<div class="line">      imageAtomicAdd( <span class="comment">/*image*/</span>uDataPooly, <span class="comment">/*coordinate*/</span>uBrickAddress * 10 + voxelOffset, <span class="comment">/*data*/</span>iData.normal.y );</div>
<div class="line">      imageAtomicAdd( <span class="comment">/*image*/</span>uDataPoolz, <span class="comment">/*coordinate*/</span>uBrickAddress * 10 + voxelOffset, <span class="comment">/*data*/</span>iData.normal.z );</div>
<div class="line">  }</div>
</div><!-- fragment --><p><br  />
</p>
<hr  />
<h1><a class="anchor" id="NTree_Section"></a>
N-Tree Visualization</h1>
<p>Resolution level : 0 </p><div class="image">
<img src="voxelization_image_01.png" alt=""/>
<div class="caption">
Resolution level : 0</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="_programming_the_giga_voxels_library.html">Programming the Library</a></li><li class="navelem"><a class="el" href="_tutorials.html">Tutorials</a></li><li class="navelem"><a class="el" href="_tutorials__graphics__interoperability.html">Graphics Interoperability Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
