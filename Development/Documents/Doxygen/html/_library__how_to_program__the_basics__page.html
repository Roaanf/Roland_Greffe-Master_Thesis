<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GigaSpace: Programmation : The Basics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GigaSpace<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_library__how_to_program__the_basics__page.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Programmation : The Basics</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="GigaVoxelsLogo_div2.png" alt=""/>
</div>
<h1><a class="anchor" id="section_Library_HowToProgram_TheBasics_Introduction"></a>
Introduction</h1>
<p>In this section, we describe the basics of the Gigavoxels programmation. For the sake of simplicity, we only study the writing of a pure GPU producer with helper classes provided by the API.</p>
<p>This section will describe :</p><ul>
<li>the GigaVoxels key features</li>
<li>the GigaVoxels data production management</li>
<li>the main GigaVoxels pipeline class definition</li>
<li>writing a custom GPU Producer</li>
<li>writing a custom GPU shader</li>
<li>simplify code with the API helper classes and functions</li>
</ul>
<hr  />
<h1><a class="anchor" id="section_Library_HowToProgram_TheBasics_GigaVoxelsKeyFeatures"></a>
GigaVoxels Key Features</h1>
<p>The key elements of GigaVoxels are :</p>
<ul>
<li>Tree Data Management (space partitioning) to store and organize data (octree or generalized N3-tree, and soon BVH or kd-tree)</li>
<li>Cache System on GPU : LRU mechanismn (least recently used) to get temporal coherency</li>
<li>Data Production Management : on host, GPU, or hybrid mode. The goal is to produce data kept in cache on GPU</li>
<li>Visit algorithm to traverse data (loaded in cache) as could be done for rendering</li>
<li>Renderer (hierarchical volume ray-casting, cone tracing, emission of requests, brick marching)</li>
</ul>
<p>As shown on the following image, GigaVoxels is made of a unified data structure (geometry + texture) that holds :</p>
<ul>
<li>a space partitioning structure of nodes used for empty space compaction (an octree)</li>
<li>user data stored as brick of voxels in a multi-resolution scheme</li>
</ul>
<div class="image">
<img src="dataStructure.png" alt=""/>
</div>
<p>Each node contains an associated brick of voxels inside :</p>
<div class="image">
<img src="brickOfVoxels.png" alt=""/>
</div>
<p>During the rendering phase, the GigaVoxels renderer casts rays and traverses the spatial structure to sample data along the ray (ray-marching algorithm).</p>
<p>When a node is traversed :</p>
<ul>
<li>if associated brick of voxels has already been produced, it is renderered</li>
<li>if not, a request of production is emitted (node subdivision to refine model and add details or bricks of voxels production)</li>
</ul>
<p>Producers are then in charge of the production of data in each requested nodes.</p>
<hr  />
<h1><a class="anchor" id="section_Library_HowToProgram_TheBasics_DataProductionManagement"></a>
Data Production Management</h1>
<p>The Data Production Management is responsible for the production of nodes first and then bricks :</p>
<ul>
<li>process node requests (first CPU, then GPU stage)</li>
<li>process bricks requests (first CPU, then GPU stage)</li>
</ul>
<p>This is where users have to define their own CPU and GPU producers :</p>
<div class="image">
<img src="dataProductionManagement.png" alt=""/>
</div>
<h2><a class="anchor" id="subsection_Library_HowToProgram_TheBasics_NodeSubdivision"></a>
Node subdivision</h2>
<p>A node subdivision request is raised when user need more resolution, i.e. a data refinement. For this, GigaVoxels launches a CUDA kernel to subdivide all requested nodes. For each node, the goal is to say what will lies in its children (at a finer level of resolution). USER has to define what we call an ORACLE, i.e. a utility function used to predict what lies in children nodes.</p>
<ul>
<li>KERNEL : 1 bloc per node and 1 thread/child_node &ndash; Each node has to say what’s inside each of its child</li>
<li>INPUT : localization info of current node (LOD depth and spatial index pos)</li>
<li>INPUT : address in “node cache” where to write new child nodes</li>
<li>Test if it is in a sphere (analytically)</li>
<li>Write nodes in cache</li>
</ul>
<div class="image">
<img src="nodeSubdivision.png" alt=""/>
</div>
<h2><a class="anchor" id="subsection_Library_HowToProgram_TheBasics_BrickProduction"></a>
Brick production</h2>
<p>Beware : GigaVoxels requires that voxels are stored on node centers. Therefore, during the brick production, think about this when you test spacial requests.</p>
<p>Comparison between bricks with voxels on node centers (a) and voxels on node corners (b). We show two bricks(blue an green) and different levels of the tree, brick voxels arerepresented by colored circles.</p>
<div class="image">
<img src="voxelsPosition.png" alt=""/>
</div>
<h2><a class="anchor" id="subsection_Library_HowToProgram_TheBasics_RenderingStage"></a>
Rendering Stage</h2>
<p>Here is the sequence diagram of the Renderering Stage. In green, all methods of CUSTOM Shader are highligthed to help figuring out how to interact with it.</p>
<div class="image">
<img src="rendererSequence.png" alt=""/>
</div>
<p><br  />
 </p><hr  />
<h1><a class="anchor" id="section_Library_HowToProgram_TheBasics_DataProductionManagement"></a>
Data Production Management</h1>
<ul>
<li>Basic approach,</li>
<li>Advanced approach.</li>
</ul>
<p>In the basic approach, the library gives users two main entry points :</p><ul>
<li>the <b>Producer</b> to customize the way of providing data,</li>
<li>and the <b>Shader</b> to customize the way of shading data.</li>
</ul>
<p>Users have to define a <b>GigaVoxels Pipeline</b> thats consists in five elements :</p><ul>
<li>a <b>data structure</b>,</li>
<li>a <b>producer</b>,</li>
<li>a <b>cache</b>,</li>
<li>a <b>shader</b>,</li>
<li>and a <b>renderer</b>.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// ---- [ 1 ] ---- GigaVoxels classes forward declaration</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespace_gv_core.html">GvCore</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt; u<span class="keywordtype">int</span> r &gt; <span class="keyword">struct </span>StaticRes1D;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespace_gv_structure.html">GvStructure</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> DataTList, <span class="keyword">class</span> NodeTileRes, <span class="keyword">class</span> BrickRes, u<span class="keywordtype">int</span> BorderSize &gt; <span class="keyword">struct </span>GvVolumeTree;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> VolumeTreeType, <span class="keyword">typename</span> ProducerType, <span class="keyword">typename</span> NodeTileRes, <span class="keyword">typename</span> BrickFullRes &gt; <span class="keyword">class </span>GvVolumeTreeCache;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>GvRenderer</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> VolumeTreeType, <span class="keyword">typename</span> VolumeTreeCacheType, <span class="keyword">typename</span> ProducerType, <span class="keyword">typename</span> SampleShader &gt; <span class="keyword">class </span>VolumeTreeRendererCUDA;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 2 ] ---- USER custom classes forward declaration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Producer</span></div>
<div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> NodeRes, <span class="keyword">typename</span> BrickRes, u<span class="keywordtype">int</span> BorderSize, <span class="keyword">typename</span> VolumeTreeType &gt; <span class="keyword">class </span>CustomProducer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Shader</span></div>
<div class="line"><span class="keyword">class </span>CustomShader;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 3 ] ---- USER data structure configuration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type list representing the content of one voxel</span></div>
<div class="line"><span class="keyword">typedef</span> Loki::TL::MakeTypelist&lt; uchar4, half4 &gt;::Result <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#aa8b648ffe4e2439cdc08628a865fea88">DataType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the size of a node tile</span></div>
<div class="line"><span class="keyword">typedef</span> GvCore::StaticRes1D&lt; 2 &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#abe7051c9145b1528b0bef0b71fbd4cd9">NodeRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the size of a brick</span></div>
<div class="line"><span class="keyword">typedef</span> GvCore::StaticRes1D&lt; 8 &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a8d82930cf37033df572379c6e7145622">BrickRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the size of the border around a brick</span></div>
<div class="line"><span class="keyword">enum</span> { <a class="code hl_enumvalue" href="_gs_pipeline_manager_8h.html#a0ed680fdb405e7195d9f14032851eebba9ed6d36d6d289c0cc9dd125a67bb9b05">BrickBorderSize</a> = 1 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the total size of a brick</span></div>
<div class="line"><span class="keyword">typedef</span> GvCore::StaticRes1D&lt; 8 + 2 * BrickBorderSize &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a35118e342dd46bf939d0d081ccfb0790">RealBrickRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 4 ] ---- USER pipeline configuration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of structure we want to use.</span></div>
<div class="line"><span class="keyword">typedef</span> GvStructure::GvVolumeTree&lt; DataType, NodeRes, BrickRes, BrickBorderSize &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a220dd4c5ffb4712bcd1fce92f46e779e">VolumeTreeType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of the producer</span></div>
<div class="line"><span class="keyword">typedef</span> CustomProducer&lt; NodeRes, BrickRes, BrickBorderSize, VolumeTreeType &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a45778eb3382a33d9c25b288e54e4df04">ProducerType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of the cache we want to use.</span></div>
<div class="line"><span class="keyword">typedef</span> GvStructure::GvVolumeTreeCache&lt; VolumeTreeType, ProducerType, NodeRes, RealBrickRes &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a587f4d0882b30f9e28ed9fd3d6935a79">VolumeTreeCacheType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of the shader</span></div>
<div class="line"><span class="keyword">typedef</span> CustomShader <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#ad177a7d968554eb5dadd3417b260676d">ShaderType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of the renderer we want to use.</span></div>
<div class="line"><span class="keyword">typedef</span> GvRenderer::VolumeTreeRendererCUDA&lt; VolumeTreeType, VolumeTreeCacheType, ProducerType, ShaderType &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a1661c64b4618cdaa79ae1ff2556015a9">VolumeTreeRendererType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 5 ] ---- USER custom pipeline definition</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_sample_core.html">SampleCore</a></div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">    DataStructureType* _dataStructure;</div>
<div class="line"> </div>
<div class="line">    CacheType* _cache;</div>
<div class="line"> </div>
<div class="line">    RendererType* _renderer;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_producer_load.html">ProducerType</a>* _producer;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a0ed680fdb405e7195d9f14032851eebba9ed6d36d6d289c0cc9dd125a67bb9b05"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a0ed680fdb405e7195d9f14032851eebba9ed6d36d6d289c0cc9dd125a67bb9b05">BrickBorderSize</a></div><div class="ttdeci">@ BrickBorderSize</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:117</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a1661c64b4618cdaa79ae1ff2556015a9"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a1661c64b4618cdaa79ae1ff2556015a9">VolumeTreeRendererType</a></div><div class="ttdeci">GvRendering::GsRendererCUDA&lt; VolumeTreeType, VolumeTreeCacheType, ProducerType, ShaderType &gt; VolumeTreeRendererType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:141</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a220dd4c5ffb4712bcd1fce92f46e779e"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a220dd4c5ffb4712bcd1fce92f46e779e">VolumeTreeType</a></div><div class="ttdeci">GvStructure::GsVolumeTree&lt; DataType, NodeRes, BrickRes, BrickBorderSize &gt; VolumeTreeType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:131</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a35118e342dd46bf939d0d081ccfb0790"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a35118e342dd46bf939d0d081ccfb0790">RealBrickRes</a></div><div class="ttdeci">GvCore::GsVec1D&lt; 8+2 *BrickBorderSize &gt; RealBrickRes</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:120</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a45778eb3382a33d9c25b288e54e4df04"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a45778eb3382a33d9c25b288e54e4df04">ProducerType</a></div><div class="ttdeci">ProducerLoad&lt; DataType, NodeRes, BrickRes, BrickBorderSize &gt; ProducerType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:127</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a587f4d0882b30f9e28ed9fd3d6935a79"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a587f4d0882b30f9e28ed9fd3d6935a79">VolumeTreeCacheType</a></div><div class="ttdeci">GvStructure::GsDataProductionManager&lt; VolumeTreeType, ProducerType, NodeRes, RealBrickRes &gt; VolumeTreeCacheType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:136</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_a8d82930cf37033df572379c6e7145622"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#a8d82930cf37033df572379c6e7145622">BrickRes</a></div><div class="ttdeci">GvCore::GsVec1D&lt; 8 &gt; BrickRes</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:114</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_aa8b648ffe4e2439cdc08628a865fea88"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#aa8b648ffe4e2439cdc08628a865fea88">DataType</a></div><div class="ttdeci">Loki::TL::MakeTypelist&lt; uchar4 &gt;::Result DataType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:108</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_abe7051c9145b1528b0bef0b71fbd4cd9"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#abe7051c9145b1528b0bef0b71fbd4cd9">NodeRes</a></div><div class="ttdeci">GvCore::GsVec1D&lt; 2 &gt; NodeRes</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:111</div></div>
<div class="ttc" id="a_gs_pipeline_manager_8h_html_ad177a7d968554eb5dadd3417b260676d"><div class="ttname"><a href="_gs_pipeline_manager_8h.html#ad177a7d968554eb5dadd3417b260676d">ShaderType</a></div><div class="ttdeci">ShaderLoad ShaderType</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:123</div></div>
<div class="ttc" id="aclass_producer_load_html"><div class="ttname"><a href="class_producer_load.html">ProducerLoad</a></div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:102</div></div>
<div class="ttc" id="aclass_sample_core_html"><div class="ttname"><a href="class_sample_core.html">SampleCore</a></div><div class="ttdoc">The SampleCore class provides...</div><div class="ttdef"><b>Definition</b> GsPipelineManager.h:155</div></div>
<div class="ttc" id="anamespace_gv_core_html"><div class="ttname"><a href="namespace_gv_core.html">GvCore</a></div><div class="ttdef"><b>Definition</b> GsArray.h:81</div></div>
<div class="ttc" id="anamespace_gv_structure_html"><div class="ttname"><a href="namespace_gv_structure.html">GvStructure</a></div><div class="ttdef"><b>Definition</b> GsDataProductionManager.h:101</div></div>
</div><!-- fragment --><p><br  />
 </p><hr  />
<h1><a class="anchor" id="section_Library_HowToProgram_TheBasics_ProducerWriting"></a>
Writing a GPU Producer</h1>
<h2><a class="anchor" id="section_Library_HowToProgram_TheBasics_ProducerWriting_Overview"></a>
Overview</h2>
<p>To write a producer, users have to :</p><ul>
<li>first, deriving from the GvCore::GvIProvider class,</li>
<li>then handle the common GvCore::GvIProvider::produceData() method.</li>
</ul>
<p>During the final <b>Update Phase</b> step of the GigaVoxels Pipeline, the Cache Mecanism asks the producer to provide its data by calling the GvCore::GvIProvider::produceData(). The producer receives useful information (nodes addresses, localization information, etc...) needed to provide data either by loading it from disk, or generates it procedurally on device (i.e GPU).</p>
<h2><a class="anchor" id="section_Library_HowToProgram_TheBasics_ProducerWriting_Definition"></a>
Class Definition</h2>
<p>User must provide two types of producers :</p><ul>
<li>one on HOST (i.e. CPU),</li>
<li>one on DEVICE (i.e. GPU).</li>
</ul>
<p>At minimum, to create a HOST provider, user must derive from GvCore::GvIProvider class two times. One derivation for each pool, i.e. :</p><ul>
<li>the node pool,</li>
<li>and the brick pool.</li>
</ul>
<p>In GigaVoxels, pool indexes are defined as follow :</p><ul>
<li>index 0 stands for the node pool (node tiles),</li>
<li>index 1 stands for the brick pool (voxels).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomProducer</div>
<div class="line">:    <span class="keyword">public</span> GvCore::GvIProvider&lt; 0, CustomProducer &gt;</div>
<div class="line">,    <span class="keyword">public</span> GvCore::GvIProvider&lt; 1, CustomProducer &gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Implement the produceData() method for the channel 0 (nodes)</span></div>
<div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> ElementRes, <span class="keyword">typename</span> GPUPoolType, <span class="keyword">typename</span> PageTableType &gt;</div>
<div class="line">   <span class="keyword">inline</span> <span class="keywordtype">void</span> produceData( <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pNumElems,</div>
<div class="line">                            thrust::device_vector&lt; uint &gt;* pNodesAddressCompactList,</div>
<div class="line">                            thrust::device_vector&lt; uint &gt;* pElemAddressCompactList,</div>
<div class="line">                            GPUPoolType&amp; pGpuPool,</div>
<div class="line">                            PageTableType pPageTable, Loki::Int2Type&lt; 0 &gt; );</div>
<div class="line">     </div>
<div class="line">   <span class="comment">// Implement the produceData() method for the channel 1 (bricks)</span></div>
<div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> ElementRes, <span class="keyword">typename</span> GPUPoolType, <span class="keyword">typename</span> PageTableType &gt;</div>
<div class="line">   <span class="keyword">inline</span> <span class="keywordtype">void</span> produceData( <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pNumElems,</div>
<div class="line">                            thrust::device_vector&lt; uint &gt;* pNodesAddressCompactList,</div>
<div class="line">                            thrust::device_vector&lt; uint &gt;* pElemAddressCompactList,</div>
<div class="line">                            GPUPoolType&amp; pGpuPool,</div>
<div class="line">                            PageTableType pPageTable, Loki::Int2Type&lt; 1 &gt; );</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Cache helper</span></div>
<div class="line">    <a class="code hl_function" href="namespace_gv_cache.html#af0279ace4b628f0b0c55b4070c6008ed">GvCache::GvCacheHelper</a> _cacheHelper;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Kernel producer</span></div>
<div class="line">    CustomProducerKernel _kernelProducer;</div>
<div class="line">};</div>
<div class="ttc" id="a_gs_vector_types_ext_8h_html_a91ad9478d81a7aaf2593e8d9c3d06a14"><div class="ttname"><a href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></div><div class="ttdeci">unsigned int uint</div><div class="ttdef"><b>Definition</b> GsVectorTypesExt.h:82</div></div>
<div class="ttc" id="anamespace_gv_cache_html_af0279ace4b628f0b0c55b4070c6008ed"><div class="ttname"><a href="namespace_gv_cache.html#af0279ace4b628f0b0c55b4070c6008ed">GvCache::CacheManagerCreateUpdateMask</a></div><div class="ttdeci">__global__ void CacheManagerCreateUpdateMask(const uint pNbElements, const uint *__restrict__ pUpdateList, uint *__restrict__ pResMask, const uint pFlag)</div><div class="ttdef"><b>Definition</b> GsCacheManagerKernel.h:294</div></div>
</div><!-- fragment --><p>The Loki library provides the Loki::Int2Type&lt;&gt; template structure that converts each integral constant into a unique type.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keywordtype">int</span> v &gt;</div>
<div class="line"><span class="keyword">struct </span>Int2Type</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">enum</span> { value = v };</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is used to specialized the GvCore::GvIProvider::produceData() method, based on the pool indexes.</p>
<p>At minimum, to create a DEVICE provider, users don't have to herit from the GvCore::GvIProviderKernel class, but must write its GvCore::GvIProviderKernel::produceData() method. As for the HOST, one method for each pool.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomProducerKernel</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Implement the produceData() method for the channel 0 (nodes)</span></div>
<div class="line">    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> TGPUPoolKernelType &gt;</div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> produceData( TGPUPoolKernelType&amp; pGpuPool,</div>
<div class="line">                             <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pRequestID,</div>
<div class="line">                             <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pProcessID,</div>
<div class="line">                             uint3 pNewElemAddress,</div>
<div class="line">                             <span class="keyword">const</span> GvLocalizationInfo&amp; pParentLocInfo,</div>
<div class="line">                             Loki::Int2Type&lt; 0 &gt; );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Implement the produceData() method for the channel 1 (bricks)</span></div>
<div class="line">    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> TGPUPoolKernelType &gt;</div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> produceData( TGPUPoolKernelType&amp; pGpuPool,</div>
<div class="line">                             <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pRequestID,</div>
<div class="line">                             <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pProcessID,</div>
<div class="line">                             uint3 pNewElemAddress,</div>
<div class="line">                             <span class="keyword">const</span> GvLocalizationInfo&amp; pParentLocInfo,</div>
<div class="line">                             Loki::Int2Type&lt; 1 &gt; );</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="section_Library_HowToProgram_TheBasics_ProducerWriting_Implementation"></a>
Class Implementation</h2>
<p>Now that users have defined their providers, they have to implement them.</p>
<p>Here is the HOST provider implementation for the node pool (index is 0).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TElementRes, <span class="keyword">typename</span> TGPUPoolType, <span class="keyword">typename</span> TPageTableType &gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> CustomProducer::produceData( <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pNumElems,</div>
<div class="line">                                         thrust::device_vector&lt; uint &gt;* pNodesAddressCompactList,</div>
<div class="line">                                         thrust::device_vector&lt; uint &gt;* pElemAddressCompactList,</div>
<div class="line">                                         TGPUPoolType pGpuPool,</div>
<div class="line">                                         TPageTableType pPageTable,</div>
<div class="line">                                         Loki::Int2Type&lt; 0 &gt; )</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Here, we are dealing with a pure device (GPU) producer,</span></div>
<div class="line">    <span class="comment">// that&#39;s why the host (CPU) producer only defines its associated device producer,</span></div>
<div class="line">    <span class="comment">// then pass parameters to the helper object _cacheHelper,</span></div>
<div class="line">    <span class="comment">// whose role is to call the device producer.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize GvCore::GvIProviderKernel with the user DEVICE producer</span></div>
<div class="line">    GvCore::GvIProviderKernel&lt; 0, CustomProducerKernel &gt; kernelProvider( _kernelProducer );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a 1D kernel block size.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This defines how we will access data in the producer kernel,</span></div>
<div class="line">    <span class="comment">// where each node will be produced separatly in parallel.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Generally, for nodes production, we use a 1D kernel</span></div>
<div class="line">    <span class="comment">// because we have to produce 8 children for an octree data structure.</span></div>
<div class="line">    <span class="comment">// (for details, see below for the device producer)</span></div>
<div class="line">    dim3 blockSize( 32, 1, 1 );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Retrieve updated addresses from the &quot;node cache manager&quot;</span></div>
<div class="line">    <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>* nodesAddressList = thrust::raw_pointer_cast( &amp;(*pNodesAddressCompactList)[ 0 ] );</div>
<div class="line">    <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>* elemAddressList = thrust::raw_pointer_cast( &amp;(*pElemAddressCompactList)[ 0 ] );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Call the cache helper to write into the GPU cache</span></div>
<div class="line">    _cacheHelper.genericWriteIntoCache&lt; TElementRes &gt;( pNumElems,</div>
<div class="line">                                                       nodesAddressList,</div>
<div class="line">                                                       elemAddressList,</div>
<div class="line">                                                       pGpuPool,</div>
<div class="line">                                                       kernelProvider,</div>
<div class="line">                                                       pPageTable,</div>
<div class="line">                                                       blockSize );</div>
<div class="line">}</div>
</div><!-- fragment --><p>For is the HOST provider implementation of the brick pool (index is 1), code is the same except for the pool index. Furthermore, the kernel block size is modified to be 2D.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TElementRes, <span class="keyword">typename</span> TGPUPoolType, <span class="keyword">typename</span> TPageTableType &gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> CustomProducer::produceData( <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> pNumElems,</div>
<div class="line">                                         thrust::device_vector&lt; uint &gt;* pNodesAddressCompactList,</div>
<div class="line">                                         thrust::device_vector&lt; uint &gt;* pElemAddressCompactList,</div>
<div class="line">                                         TGPUPoolType pGpuPool,</div>
<div class="line">                                         TPageTableType pPageTable,</div>
<div class="line">                                         Loki::Int2Type&lt; 1 &gt; )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Here, we are dealing with a pure device (GPU) producer,</span></div>
<div class="line">    <span class="comment">// that&#39;s why the host (CPU) producer only defines its associated device producer,</span></div>
<div class="line">    <span class="comment">// then pass parameters to the helper object _cacheHelper,</span></div>
<div class="line">    <span class="comment">// whose role is to call the device producer.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize GvCore::GvIProviderKernel with the user DEVICE producer</span></div>
<div class="line">    GvCore::GvIProviderKernel&lt; 1, CustomProducerKernel &gt; kernelProvider( _kernelProducer );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a 2D kernel block size</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// This defines how we will access data in the producer kernel,</span></div>
<div class="line">    <span class="comment">// where each brick of voxels will be produced separatly in parallel.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Generally, for nodes production, we use a 2D kernel</span></div>
<div class="line">    <span class="comment">// because we have to produce 8*8*8 voxels for a brick of size 8x8x8 voxels.</span></div>
<div class="line">    <span class="comment">// (for details, see below for the device producer)</span></div>
<div class="line">    dim3 blockSize( 16, 8, 1 );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Retrieve updated addresses from the &quot;brick cache manager&quot;</span></div>
<div class="line">    <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>* nodesAddressList = thrust::raw_pointer_cast( &amp;(*pNodesAddressCompactList)[ 0 ] );</div>
<div class="line">    <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>* elemAddressList = thrust::raw_pointer_cast( &amp;(*pElemAddressCompactList)[ 0 ] );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Call the cache helper to write into the GPU cache</span></div>
<div class="line">    _cacheHelper.genericWriteIntoCache&lt; TElementRes &gt;( pNumElems,</div>
<div class="line">                                                       nodesAddressList,</div>
<div class="line">                                                       elemAddressList,</div>
<div class="line">                                                       pGpuPool,</div>
<div class="line">                                                       kernelProvider,</div>
<div class="line">                                                       pPageTable,</div>
<div class="line">                                                       blockSize );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, users must implement the DEVICE provider's produceData() method for each pool.</p>
<p><b>The KEY concept to note is that in an implementation of a GvCore::GvIProviderKernel::produceData() method, the user will deal with ONE element at a time, i.e. either a node tile or a brick of voxels.</b></p>
<p>Concerning <b>Node Tile Production</b>, given input parameters, the user has to :</p><ul>
<li>retrieve the 3D spatial extent of a node (i.e. world position) in the current node tile,</li>
<li>determine if it is an empty region or a constant region, a region containing data, or if we have reach the maximum depth of the data structure (this is what we call an oracle).</li>
<li>update the node pool by writing this information.</li>
</ul>
<p>Then, for all regions marked as containting data, brick production will be processed.</p>
<p>Concerning <b>Brick Production</b> (i.e. voxels data), given input parameters, the user has to :</p><ul>
<li>retrieve the 3D spatial extent of a voxel (i.e. world position) in the current brick,</li>
<li>determine and/or compute voxel value for each channel of the brick pool (i.e. color, normal, density, etc...)</li>
<li>update the brick pool by writing this information.</li>
</ul>
<p>Here is the one for the node pool (index is 0).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TGPUPoolKernelType &gt;</div>
<div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> CustomProducerKernel::produceData( TGPUPoolKernelType&amp; nodePool,</div>
<div class="line">                                               <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> requestID,</div>
<div class="line">                                               <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> processID,</div>
<div class="line">                                               uint3 newElemAddress,</div>
<div class="line">                                               <span class="keyword">const</span> GvCore::GvLocalizationInfo&amp; parentLocInfo,</div>
<div class="line">                                               Loki::Int2Type&lt; 0 &gt; )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// NOTE :</span></div>
<div class="line">    <span class="comment">// In this method, you are inside a node tile.</span></div>
<div class="line">    <span class="comment">// The goal is to determine, for each node of the node tile, which type of data it holds.</span></div>
<div class="line">    <span class="comment">// Data type can be :</span></div>
<div class="line">    <span class="comment">// - a constant region,</span></div>
<div class="line">    <span class="comment">// - a region with data,</span></div>
<div class="line">    <span class="comment">// - a region where max resolution is reached.</span></div>
<div class="line">    <span class="comment">// So, one thread is responsible of the production of one node of a node tile.</span></div>
<div class="line">     </div>
<div class="line">    <span class="comment">// Retrieve current node tile localization information code and depth</span></div>
<div class="line">    <span class="keyword">const</span> GvCore::GvLocalizationInfo::CodeType parentLocCode = parentLocInfo.locCode;</div>
<div class="line">    <span class="keyword">const</span> GvCore::GvLocalizationInfo::DepthType parentLocDepth = parentLocInfo.locDepth;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Process ID gives the 1D index of a node in the current node tile</span></div>
<div class="line">    <span class="keywordflow">if</span> ( processID &lt; <a class="code hl_function" href="struct_gv_core_1_1_gs_vec3_d.html#aa2b5e9f0e881862f914ab2a8d87c0182">NodeRes::getNumElements</a>() )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// First, compute the 3D offset of the node in the node tile</span></div>
<div class="line">        uint3 subOffset = <a class="code hl_function" href="struct_gv_core_1_1_gs_vec3_d.html#a1d1919bdb72f4148619d85ecc5d89895">NodeRes::toFloat3</a>( processID );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Node production corresponds to subdivide a node tile.</span></div>
<div class="line">        <span class="comment">// So, based on the index of the node, find the node child.</span></div>
<div class="line">        <span class="comment">// As we want to sudbivide the curent node, we retrieve localization information</span></div>
<div class="line">        <span class="comment">// at the next level</span></div>
<div class="line">        uint3 regionCoords = parentLocCode.addLevel&lt; <a class="code hl_struct" href="struct_gv_core_1_1_gs_vec1_d.html">NodeRes</a> &gt;( subOffset ).get();</div>
<div class="line">        <a class="code hl_typedef" href="_gs_vector_types_ext_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> regionDepth = parentLocDepth.addLevel().get();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Create a new node for which you will have to fill its information.</span></div>
<div class="line">        GvStructure::OctreeNode newnode;</div>
<div class="line">        newnode.childAddress = 0;</div>
<div class="line">        newnode.brickAddress = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Call what we call an oracle that will determine the type of the region of the node accordingly</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// For instance, to generate a sphere on device (GPU),</span></div>
<div class="line">        <span class="comment">// you could test if the 8 corners of the node tile are inside an analytical function of a sphere.</span></div>
<div class="line">        GPUVoxelProducer::GPUVPRegionInfo nodeinfo = getRegionInfo( regionCoords, regionDepth );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now that the type of the region is found, fill the new node information</span></div>
<div class="line">        <span class="keywordflow">if</span> ( nodeinfo == GPUVoxelProducer::GPUVP_CONSTANT )</div>
<div class="line">        {</div>
<div class="line">            newnode.setTerminal(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( nodeinfo == GPUVoxelProducer::GPUVP_DATA )</div>
<div class="line">        {</div>
<div class="line">            newnode.setStoreBrick();</div>
<div class="line">            newnode.setTerminal( <span class="keyword">false</span> );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( nodeinfo == GPUVoxelProducer::GPUVP_DATA_MAXRES )</div>
<div class="line">        {</div>
<div class="line">            newnode.setStoreBrick();</div>
<div class="line">            newnode.setTerminal( <span class="keyword">true</span> );</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Finally, write the new node information into the node pool by selecting channels :</span></div>
<div class="line">        <span class="comment">// - Loki::Int2Type&lt; 0 &gt;() points to node information</span></div>
<div class="line">        <span class="comment">// - Loki::Int2Type&lt; 1 &gt;() points to brick information</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// newElemAddress.x + processID : is the adress of the new node in the node pool</span></div>
<div class="line">        nodePool.getChannel( Loki::Int2Type&lt; 0 &gt;() ).set( newElemAddress.x + processID, newnode.childAddress );</div>
<div class="line">        nodePool.getChannel( Loki::Int2Type&lt; 1 &gt;() ).set( newElemAddress.x + processID, newnode.brickAddress );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astruct_gv_core_1_1_gs_vec1_d_html"><div class="ttname"><a href="struct_gv_core_1_1_gs_vec1_d.html">GvCore::GsVec1D</a></div><div class="ttdoc">The GsVec1D struct provides the concept of a uniform 3D resolution.</div><div class="ttdef"><b>Definition</b> GsVector.h:258</div></div>
<div class="ttc" id="astruct_gv_core_1_1_gs_vec3_d_html_a1d1919bdb72f4148619d85ecc5d89895"><div class="ttname"><a href="struct_gv_core_1_1_gs_vec3_d.html#a1d1919bdb72f4148619d85ecc5d89895">GvCore::GsVec3D&lt; Tr, Tr, Tr &gt;::toFloat3</a></div><div class="ttdeci">__host__ static __device__ uint3 toFloat3(uint pValue)</div><div class="ttdef"><b>Definition</b> GsVector.inl:141</div></div>
<div class="ttc" id="astruct_gv_core_1_1_gs_vec3_d_html_aa2b5e9f0e881862f914ab2a8d87c0182"><div class="ttname"><a href="struct_gv_core_1_1_gs_vec3_d.html#aa2b5e9f0e881862f914ab2a8d87c0182">GvCore::GsVec3D&lt; Tr, Tr, Tr &gt;::getNumElements</a></div><div class="ttdeci">__device__ static __host__ uint getNumElements()</div><div class="ttdef"><b>Definition</b> GsVector.inl:84</div></div>
</div><!-- fragment --><p><br  />
 </p><hr  />
<h1><a class="anchor" id="section_Library_HowToProgram_TheBasics_ShaderWriting"></a>
Writing a Shader</h1>
<h2><a class="anchor" id="section_Library_HowToProgram_TheBasics_ShaderWriting_Definition"></a>
Class Definition</h2>
<p>User must provide two types of shaders :</p><ul>
<li>one on HOST (i.e. CPU),</li>
<li>one on DEVICE (i.e. GPU).</li>
</ul>
<p>At minimum, to create a HOST shader, users don't have to herit from one of the API classes, but must provide a type definition for its associted device-side class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomShader</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> CustomShaderKernel KernelType;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>At minimum, to create a DEVICE shader, user must derive from GvCore::GvIRenderShader class. Currently, users must implement all methods defined in the GvCore::GvIRenderShader.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomShaderKernel : <span class="keyword">public</span> GvCore::GvIRenderShader&lt; CustomShaderKernel &gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> preShadeImpl( <span class="keyword">const</span> float3&amp; rayStartTree, <span class="keyword">const</span> float3&amp; rayDirTree, <span class="keywordtype">float</span>&amp; tTree );</div>
<div class="line"> </div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> postShadeImpl();</div>
<div class="line"> </div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">float</span> getConeApertureImpl( <span class="keyword">const</span> <span class="keywordtype">float</span> tTree ) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> float4 getColorImpl() <span class="keyword">const</span>;</div>
<div class="line">     </div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">bool</span> stopCriterionImpl( <span class="keyword">const</span> float3&amp; rayPosInWorld ) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">bool</span> descentCriterionImpl( <span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize ) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> SamplerType &gt;</div>
<div class="line">    __device__</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> runImpl( <span class="keyword">const</span> SamplerType&amp; brickSampler,</div>
<div class="line">                         <span class="keyword">const</span> float3 samplePosScene,</div>
<div class="line">                         <span class="keyword">const</span> float3 rayDir,</div>
<div class="line">                         <span class="keywordtype">float</span>&amp; rayStep,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">float</span> coneAperture );</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">    float4 _accColor;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="section_Library_HowToProgram_TheBasics_ShaderWriting_Implementation"></a>
Class Implementation</h2>
<p>Users don't have to implement specific stuff for the HOST shader, but only for the DEVICE one, i.e. all methods defined in the GvCore::GvIRenderShader class.</p>
<div class="fragment"><div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> SphereShaderKernel::preShadeImpl( <span class="keyword">const</span> float3&amp; rayStartTree, <span class="keyword">const</span> float3&amp; rayDirTree, <span class="keywordtype">float</span>&amp; tTree )</div>
<div class="line">{</div>
<div class="line">    _accColor = <a class="code hl_function" href="_gs_vector_types_ext_8h.html#ae83c0fd23e2664109a14cfddd94bdb4a">make_float4</a>(0.f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> SphereShaderKernel::postShadeImpl()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> ( _accColor.w &gt;= opacityThreshold )</div>
<div class="line">    {</div>
<div class="line">        _accColor.w = 1.f;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">float</span> SphereShaderKernel::getConeApertureImpl( <span class="keyword">const</span> <span class="keywordtype">float</span> tTree )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// Overestimate to avoid aliasing</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> scaleFactor = 1.333f;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variable" href="_gs_renderer_context_8h.html#a05193bd5a03e953d006194e123cfb0e1">k_renderViewContext</a>.<a class="code hl_variable" href="struct_gv_rendering_1_1_gs_renderer_context.html#abccfe7e1eaf993cfe5243506f7fe68e3">pixelSize</a>.x * tTree * scaleFactor * <a class="code hl_variable" href="_gs_renderer_context_8h.html#a05193bd5a03e953d006194e123cfb0e1">k_renderViewContext</a>.<a class="code hl_variable" href="struct_gv_rendering_1_1_gs_renderer_context.html#acdfb1bc57d2253f2708e3819cca6a74f">frustumNearINV</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> float4 SphereShaderKernel::getColorImpl()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> _accColor;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> SphereShaderKernel::stopCriterionImpl( <span class="keyword">const</span> float3&amp; rayPosInWorld )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> ( _accColor.w &gt;= opacityThreshold );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> SphereShaderKernel::descentCriterionImpl( <span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> SamplerType &gt;</div>
<div class="line">__device__</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> SphereShaderKernel::runImpl( <span class="keyword">const</span> SamplerType&amp; brickSampler, <span class="keyword">const</span> float3 samplePosScene,</div>
<div class="line"><span class="keyword">const</span> float3 rayDir, <span class="keywordtype">float</span>&amp; rayStep, <span class="keyword">const</span> <span class="keywordtype">float</span> coneAperture )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Retrieve first channel element : color</span></div>
<div class="line">    float4 color = brickSampler.template getValue&lt; 0 &gt;( coneAperture );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Test opacity</span></div>
<div class="line">    <span class="keywordflow">if</span> ( color.w &gt; 0.0f )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Retrieve second channel element : normal</span></div>
<div class="line">        float4 normal = brickSampler.template getValue&lt; 1 &gt;( coneAperture );</div>
<div class="line"> </div>
<div class="line">        float3 normalVec = normalize( <a class="code hl_function" href="_gs_vector_types_ext_8h.html#a5465e0121edabc562698dea5bf61b66d">make_float3</a>( normal.x, normal.y, normal.z ) );</div>
<div class="line">        float3 lightVec = normalize( lightPosition );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Lambertian lighting</span></div>
<div class="line">        float3 rgb = <a class="code hl_function" href="_gs_vector_types_ext_8h.html#a5465e0121edabc562698dea5bf61b66d">make_float3</a>( color.x, color.y, color.z ) * <a class="code hl_function" href="_gs_vector_types_ext_8h.html#ac9a394b83bb2423afaa4838fc704be93">max</a>( 0.0f, dot( normalVec, lightVec ) );</div>
<div class="line"> </div>
<div class="line">        color.x = rgb.x;</div>
<div class="line">        color.y = rgb.y;</div>
<div class="line">        color.z = rgb.z;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accumulate the color</span></div>
<div class="line">    _accColor = _accColor + ( 1.0f - _accColor.w ) * color;</div>
<div class="line">}</div>
<div class="ttc" id="a_gs_renderer_context_8h_html_a05193bd5a03e953d006194e123cfb0e1"><div class="ttname"><a href="_gs_renderer_context_8h.html#a05193bd5a03e953d006194e123cfb0e1">k_renderViewContext</a></div><div class="ttdeci">__constant__ GvRendering::GsRendererContext k_renderViewContext</div><div class="ttdef"><b>Definition</b> GsRendererContext.h:275</div></div>
<div class="ttc" id="a_gs_vector_types_ext_8h_html_a5465e0121edabc562698dea5bf61b66d"><div class="ttname"><a href="_gs_vector_types_ext_8h.html#a5465e0121edabc562698dea5bf61b66d">make_float3</a></div><div class="ttdeci">__host__ __device__ float3 make_float3(const uchar3 &amp;v)</div><div class="ttdef"><b>Definition</b> GsVectorTypesExt.h:382</div></div>
<div class="ttc" id="a_gs_vector_types_ext_8h_html_ac9a394b83bb2423afaa4838fc704be93"><div class="ttname"><a href="_gs_vector_types_ext_8h.html#ac9a394b83bb2423afaa4838fc704be93">max</a></div><div class="ttdeci">__host__ __device__ float3 max(const float3 &amp;d1, const float3 &amp;d2)</div><div class="ttdef"><b>Definition</b> GsVectorTypesExt.h:583</div></div>
<div class="ttc" id="a_gs_vector_types_ext_8h_html_ae83c0fd23e2664109a14cfddd94bdb4a"><div class="ttname"><a href="_gs_vector_types_ext_8h.html#ae83c0fd23e2664109a14cfddd94bdb4a">make_float4</a></div><div class="ttdeci">__host__ __device__ float4 make_float4(const float4 &amp;v)</div><div class="ttdef"><b>Definition</b> GsVectorTypesExt.h:392</div></div>
<div class="ttc" id="astruct_gv_rendering_1_1_gs_renderer_context_html_abccfe7e1eaf993cfe5243506f7fe68e3"><div class="ttname"><a href="struct_gv_rendering_1_1_gs_renderer_context.html#abccfe7e1eaf993cfe5243506f7fe68e3">GvRendering::GsRendererContext::pixelSize</a></div><div class="ttdeci">float2 pixelSize</div><div class="ttdef"><b>Definition</b> GsRendererContext.h:173</div></div>
<div class="ttc" id="astruct_gv_rendering_1_1_gs_renderer_context_html_acdfb1bc57d2253f2708e3819cca6a74f"><div class="ttname"><a href="struct_gv_rendering_1_1_gs_renderer_context.html#acdfb1bc57d2253f2708e3819cca6a74f">GvRendering::GsRendererContext::frustumNearINV</a></div><div class="ttdeci">float frustumNearINV</div><div class="ttdef"><b>Definition</b> GsRendererContext.h:150</div></div>
</div><!-- fragment --><p><br  />
 </p><hr  />
<h1><a class="anchor" id="section_Library_HowToProgram_TheBasics_HelperClassesAndFunctions"></a>
Helper classes and functions</h1>
<p>The API gives user useful helper classes :</p><ul>
<li>common host producer,</li>
<li>common host and device shader,</li>
<li>common pipeline.</li>
</ul>
<h2><a class="anchor" id="Using"></a>
Common Host Producer</h2>
<p>The structure.</p>
<h2><a class="anchor" id="Using"></a>
Common Host Producer</h2>
<p>The structure.</p>
<div class="fragment"><div class="line"><span class="comment">// ---- [ 1 ] ---- GigaVoxels classes forward declaration</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;GvUtils/GvForwardDeclarationHelper.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 2 ] ---- USER custom classes forward declaration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom Producer</span></div>
<div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TDataStructureType &gt; <span class="keyword">class </span>ProducerKernel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom Shader</span></div>
<div class="line"><span class="keyword">class </span>ShaderKernel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 3 ] ---- USER data structure configuration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type list representing the content of one voxel</span></div>
<div class="line"><span class="keyword">typedef</span> Loki::TL::MakeTypelist&lt; uchar4, half4 &gt;::Result <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#aa8b648ffe4e2439cdc08628a865fea88">DataType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the size of a node tile</span></div>
<div class="line"><span class="comment">// We use a generalized N3-tree with 2 child in each dimension, i.e. an octree</span></div>
<div class="line"><span class="keyword">typedef</span> GvCore::StaticRes1D&lt; 2 &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#abe7051c9145b1528b0bef0b71fbd4cd9">NodeRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the size of a brick</span></div>
<div class="line"><span class="comment">// We choose bricks with 8x8x8 voxels</span></div>
<div class="line"><span class="keyword">typedef</span> GvCore::StaticRes1D&lt; 8 &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a8d82930cf37033df572379c6e7145622">BrickRes</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 4 ] ---- USER pipeline configuration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of structure we want to use</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The data structure is parameterized by the data type of voxels, the N3-tree node resolution and its associted bricks content.</span></div>
<div class="line"><span class="keyword">typedef</span> GvStructure::GvVolumeTree&lt; DataType, NodeRes, BrickRes &gt; DataStructureType;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of the producer</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// GvSimpleHostProducer defines a pass-through host producer. It only sends the production requests to its associated device-side producer.</span></div>
<div class="line"><span class="keyword">typedef</span> GvUtils::GvSimpleHostProducer&lt; ProducerKernel&lt; DataStructureType &gt;, DataStructureType &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#a45778eb3382a33d9c25b288e54e4df04">ProducerType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defines the type of the shader</span></div>
<div class="line"><span class="keyword">typedef</span> GvUtils::GvSimpleHostShader&lt; ShaderKernel &gt; <a class="code hl_typedef" href="_gs_pipeline_manager_8h.html#ad177a7d968554eb5dadd3417b260676d">ShaderType</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simple Pipeline</span></div>
<div class="line"><span class="keyword">typedef</span> GvUtils::GvSimplePipeline&lt; ProducerType, ShaderType, DataStructureType &gt; PipelineType;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---- [ 5 ] ---- USER custom pipeline definition</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_sample_core.html">SampleCore</a></div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">    PipelineType* _pipeline;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="_programming_the_giga_voxels_library.html">Programming the Library</a></li><li class="navelem"><a class="el" href="_library__how_to_program.html">Programmation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
